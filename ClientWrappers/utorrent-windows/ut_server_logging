#!/bin/bash

# USAGE:
# $0 clientDir workingDir torrentFile stopWhenSeeding [dataFile]
#
# clientDir will contain the lock files for sockets, this should be a shared directory for all clients on the same machine
# workingDir will be cleaned out (rm -rf *), webui.zip and utorrent.exe will be copied in
# torrentFile will be loaded and downloaded
# stopWhenSeeding is 0 or 1; if 1 the client will be killed when the torrent has reached "Seeding" state
# if dataFile is given, it will be copied to workingDir

going=1
trap "going=0" SIGINT SIGTERM

if [ -z "$1" ]; then
    echo "No \$1"
    exit -1
fi

if [ -z "$2" ]; then
    echo "No \$2"
    exit -1
fi

if [ -z "$3" ]; then
    echo "No \$3"
    exit -1
fi

if [ ! -d "$1" ]; then  
    echo "Not a dir: $1"
    exit -1
fi

if [ ! -d "$2" ]; then  
    echo "Not a dir: $2"
    exit -1
fi

if [ ! -f "$3" ]; then
    echo "Not a file: $3"
    exit -1
fi

if [ "$4" != "0" -a "$4" != "1" ]; then
    echo "Not 0 or 1: $4"
    exit -1
fi

if [ ! -z "$5" ]; then
    if [ ! -f "$5" ]; then
        echo "Not a file: $5"
        exit -1
    fi
fi

stopWhenSeeding=0
if [ $4 -eq 1 ]; then
    stopWhenSeeding=1
fi

rm -f "$2"/* 2>/dev/null
rm -f "$2/torrents"/*

cp webui.zip "$2/"
cp utorrent.exe "$2/"
cp settings.dat "$2/"

if [ ! -z "$5" ]; then
    cp "$5" "$2/"
fi

mkdir -p "$2/torrents"
mkdir -p "$2/.wine"

PORT=6881
WEBPORT=8080
while [ $PORT -le 7000 ]; do
    (set -C; : > "$1/port_$PORT") 2> /dev/null
    # Port already taken by another of my processes?
    if [ $? != "0" ]; then
        PORT=$(($PORT + 1))
        WEBPORT=$(($WEBPORT + 1))
        continue
    fi
    # Port already taken by whomever? (this is a less safer check, which DOES include a race-condition, theoretically, hence the former check)
    if netstat -tan | grep -E ":($PORT|$WEBPORT)[[:space:]].*[[:space:]]LISTEN" > /dev/null; then
        PORT=$(($PORT + 1))
        WEBPORT=$(($WEBPORT + 1))
        continue
    fi
    break
done
if [ $PORT -gt 7000 ]; then
    echo "No open port found"
    exit -1
fi

# [fixed]
# echo "token_auth_enable: 0" >> "$2/utserver.conf"
# 63224
# echo "bind_port: $PORT" >> "$2/utserver.conf"
sed -i -e "s/63224/$PORT/" "$2/settings.dat"
# 8090
# echo "ut_webui_port: $WEBPORT" >> "$2/utserver.conf"
sed -i -e "s/8090/$WEBPORT/" "$2/settings.dat"
# 14:c:\blabladata\
# echo "dir_active: $2/" >> "$2/utserver.conf"
full_dir_path=`cd $2; pwd`
active_dir=`echo "z:$full_dir_path/" | sed -e "s@/@\\\\\\\\\\\\\@g"`
log_dir="$active_dir"
active_dir_for_count=`echo "z:$full_dir_path/" | sed -e "s@/@\\\\\\\\@g"`
sed -i -e "s/14:c:\\\\blabladata\\\\/${#active_dir_for_count}:$active_dir/" "$2/settings.dat"
# 10:c:\blabla\
# echo "dir_autoload: $2/torrents/" >> "$2/utserver.conf"
active_dir=`echo "z:$full_dir_path/torrents/" | sed -e "s@/@\\\\\\\\\\\\\@g"`
active_dir_for_count=`echo "z:$full_dir_path/torrents/" | sed -e "s@/@\\\\\\\\@g"`
sed -i -e "s/10:c:\\\\blabla\\\\/${#active_dir_for_count}:$active_dir/" "$2/settings.dat"
# 
# echo "auto_bandwidth_management: 0" >> "$2/utserver.conf"

utpath=`pwd`
cd $2
cp $utpath/utorrent.exe .
HOMEDIR=`cd ~; pwd`
PATH="$PATH:$HOMEDIR/bin"
WINEPREFIX="$2/.wine" xvfb-run -a wine utorrent.exe /noinstall /logfile "$log_dir\\ut_log.log" &
pid=$!
echo $pid > "$2/utserver.pid"
( echo $pid >&2 ) > /dev/null
( kill -0 $pid >&2 ) > /dev/null
( echo "$PORT $WEBPORT" >&2 ) > /dev/null

date +"%s.%09N"

sleep 1
pid=`cat "$2/utserver.pid"`
torrentloaded=0
# Get the loaded torrents
while [ $going -eq 1 ]; do
    ( wget -O "$2/wget.out" --load-cookies "$2/wget.cookies" --save-cookies "$2/wget.cookies" --keep-session-cookies http://admin:@localhost:$WEBPORT/gui/?list=1 2>/dev/null ) >&2 >/dev/null
    # list?1 returns:
    # {
    #       "build": BUILD NUMBER (integer),
    #       "label": [
    #               ...
    #       ],
    #       "torrents": [
    #               [ HASH (string),
    #               STATUS* (integer),
    #               NAME (string),
    #               SIZE (integer in bytes),
    # XX            PERCENT PROGRESS (integer in per mils),
    #               DOWNLOADED (integer in bytes),
    #               UPLOADED (integer in bytes),
    #               RATIO (integer in per mils),
    # XX            UPLOAD SPEED (integer in bytes per second),
    # XX            DOWNLOAD SPEED (integer in bytes per second),
    #               ETA (integer in seconds),
    #               LABEL (string),
    #               PEERS CONNECTED (integer),
    #               PEERS IN SWARM (integer),
    #               SEEDS CONNECTED (integer),
    #               SEEDS IN SWARM (integer),
    #               AVAILABILITY (integer in 1/65535ths),
    #               TORRENT QUEUE ORDER (integer),
    #               REMAINING (integer in bytes),
    #               DOWNLOAD URL (string),
    #               RSS FEED URL (string),
    #               STATUS MESSAGE (string),
    #               STREAM ID (string),
    #               ADDED ON (integer in seconds),
    #               COMPLETED ON (integer in seconds),
    #               APP UPDATE URL (string) ],
    #
    #               ...
    #       ],
    #       "rssfeeds": [
    #               ...
    #       ],
    #       "rssfilters": [
    #               ...
    #       ],
    #       "torrentc": CACHE ID** (string integer)
    # }
    if [ ! -z "`cat \"$2/wget.out\"`" ]; then
        # Lazy loading of the torrent using the dir_autoload functionality:
        # utorrent is unreliable in loading torrents that already exist when the client is started
        # so we only copy the torrent file in once the first response has been seen
        if [ $torrentloaded = 0 ]; then
            cp "$3" "$2/torrents/"
            torrentloaded=1
        fi
        date +"%s.%09N"
        cat "$2/wget.out"
        if [ $stopWhenSeeding -eq 1 ]; then
            if grep ",\"Seeding\"," "$2/wget.out" > /dev/null 2> /dev/null; then
                going=0
            fi
        fi
    fi
    sleep 1
done

( cat "$2/ut_log.log" >&2 ) > /dev/null

kill $pid
