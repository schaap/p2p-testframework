#!/bin/bash

#
# Implementation of the file API for a single local file.
# This file module supports these extra parameters:
# - path                The path to the actual file on the local machine
# - torrent             Set this to "yes" to have a torrent file automatically generated from the file; the torrent file will be uploaded and its location available through fileGetMetaName
# - generateRootHash    Set this to "yes" to have the SHA1 root hash automatically generated from the file; the rootHash parameter must not be set in this case
#

##
# Read settings from the provided settings file and save them to ${LOCAL_TEST_DIR}/files/$FILE_NAME .
# Please return false (non-0) when an error occurs, instead of calling fail.
# The way the settings are saved into ${LOCAL_TEST_DIR}/files/$FILE_NAME/ does not matter, but make sure it exists and that ${LOCAL_TEST_DIR}/files/$FILE_NAME/modulename contains the module subtype and nothing else.
#
# @param    The settings file to read from.
# @param    The line number at which this file object was defined. The first line in the settings file is at line $(($2 + 1))
#
# @return   True (0) iff the settings were parsed and saves succesfully.
##
function fileReadSettings() {
    local parameterName=""
    local parameterValue=""
    LINE_NUMBER=$(($2 + 1))
    FILE_LOCAL_PATH=""
    local file_local_torrent_requested=0
    local file_local_roothash_requested=0
    # Parse all parameters
    while IFS="" read LINE; do
        if [ "" = "$LINE" ]; then
            LINE_NUMBER=$(($LINE_NUMBER + 1))
            continue
        fi
        parameterName=`getParameterName "$LINE"`
        checkFailScenarioFile "$6"
        parameterValue=`getParameterValue "$LINE"`
        # Handle this parameter appropiately
        case $parameterName in
            name|rootHash)
                # These are the generic settings that have already been parsed. Usually one can ignore them as such.
                ;;
            path)
                if [ ! -f "$parameterValue" ]; then
                    logError "file:local :: Path to a file was given to file $FILE_NAME, but no such file exists: \"$parameterValue\" (line $LINE_NUMBER)."
                    return 1
                fi
                if [ ! -z "$FILE_LOCAL_PATH" ]; then
                    logError "file:local :: File $FILE_NAME already has a path associated with it (line $LINE_NUMBER)."
                    return 1
                fi
                FILE_LOCAL_PATH="$parameterValue"
                ;;
            torrent)
                if [ "$parameterValue" = "yes" ]; then
                    file_local_torrent_requested=1
                fi
                ;;
            generateRootHash)
                if [ "$parameterValue" = "yes" ]; then
                    if [ ! -z "$FILE_ROOTHASH" ]; then
                        logError "file:local :: File $FILE_NAME has a request to have the SHA1 root hash calculated, but it was already supplied: $FILE_ROOTHASH (line $LINE_NUMBER)."
                        return 1
                    fi
                    file_local_roothash_requested=1
                fi
                ;;
            *)
                logError "file:local :: Unknown parameter name \"$parameterName\" in file $FILE_NAME. Ignoring."
                ;;
        esac
        LINE_NUMBER=$(($LINE_NUMBER + 1))
    done < "$1";

    if [ -z "$FILE_LOCAL_PATH" ]; then
        logError "file:local :: File $FILE_NAME has not path associated with it, but that is required for files of type 'file' (line $LINE_NUMBER)."
        return 1
    fi

    # Delegate standard saving to the default implementation
    fileReadSettings__default
    # Any variables set up above should be saved like this:
    # echo "YOUR_SETTING=\"$YOUR_SETTING\"" >> "${LOCAL_TEST_DIR}/files/$FILE_NAME/conf"
    echo "FILE_LOCAL_PATH=\"$FILE_LOCAL_PATH\"" >> "${LOCAL_TEST_DIR}/files/$FILE_NAME/conf"

    # Try and create a torrent file for this single file.
    FILE_LOCAL_TORRENT=''
    if [ $file_local_torrent_requested -eq 1 ]; then
        loadFunctionsScript torrent.sh
        if torrentCreateFromSingleFile "$FILE_LOCAL_PATH" "${LOCAL_TEST_DIR}/files/$FILE_NAME/torrent.torrent"; then
            FILE_LOCAL_TORRENT="${LOCAL_TEST_DIR}/files/$FILE_NAME/torrent.torrent"
        else
            logError "file:local :: Could not generate the torrent file from local file \"$FILE_LOCAL_PATH\". Perhaps the file is too large?"
            return 1
        fi
    fi
    echo "FILE_LOCAL_TORRENT=\"$FILE_LOCAL_TORRENT\"" >> "${LOCAL_TEST_DIR}/files/$FILE_NAME/conf"

    # Try and calculate the roor hash for this single file.
    if [ $file_local_roothash_requested -eq 1 ]; then
        loadFunctionsScript merkle.sh
        if ! merkleCanCalculate; then
            logError "file:local :: Could not generate the root hash from local file \"$FILE_LOCAL_PATH\". Perhaps the file is too large?"
            return 1
        fi
        FILE_ROOTHASH=`merkleCalculateRootHashFromSingleFile "$FILE_LOCAL_PATH"`
        if [ -z "$FILE_ROOTHASH" ]; then
            logError "file:local :: No root hash was calculated for \"$FILE_LOCAL_PATH\", although requested."
            return 1
        fi
        if ! echo "$FILE_ROOTHASH" | grep -E "[[:xdigit:]]{40}" > /dev/null; then
            logError "file:local :: A root hash seemed to have been calculated, but it does not consists of 40 hexadecimal digits, as was expected. The output of the calculation: \"$FILE_ROOTHASH\"."
            return 1
        fi
        echo "FILE_ROOTHASH=\"$FILE_ROOTHASH\"" >> "${LOCAL_TEST_DIR}/files/$FILE_NAME/conf"
    fi
    
    # Finally, register our file with the environment
    FILES="$FILES $FILE_NAME"
    return 0
}

##
# Loads previously saved settings into memory.
# Be sure to override all relevant variables, whether they're saved or not.
#
# @param    The name of the file object to be loaded.
##
function fileLoadSettings() {
    # By default delegated to the default implementation, which works fine if the default implementation for fileReadSettings is used
    fileLoadSettings__default "$1" "local"
}

##
# Send any required files to the host.
# This function will be called for each host.
# Use the host API to do the actual sending of the files.
##
function fileSendToHost() {
    hostSendCommand "mkdir -p \"`hostGetTestDir`/files/$FILE_NAME/\""
    if [ ! -z "$FILE_LOCAL_TORRENT" ]; then
        hostSendFile "$FILE_LOCAL_TORRENT" "`hostGetTestDir`/files/$FILE_NAME/torrent.torrent"
    fi
}

##
# Send any files required for seeding to the host.
# This function will be called for each host on which seeding of the file is needed.
# Note that fileSendToHost will also be called, before this function is called.
# Use the host API to do the actual sending of the files.
##
function fileSendToSeedingHost() {
    hostSendFile "$FILE_LOCAL_PATH" "`hostGetTestDir`/files/$FILE_NAME/outputFile"
}

##
# Output the path to the file, or the root directory of a set of files, on the currently loaded host.
# This assumes that fileSendToHost has already been called.
# This file is only available for seeding hosts, use the execution API to verify this, if needed.
# Use the host API for host specific queries, if needed.
#
# Note that the file's name is outputFile on the remote host; this is to have an equal file name on disk as is proposed in the .torrent.
# See torrentCreateFromSingleFile.
##
function fileGetName() {
    if executionIsSeeder; then
        echo "`hostGetTestDir`/files/$FILE_NAME/outputFile"
    else
        echo ""
    fi
}

##
# Output the path to the file containing metadata on the currently loaded host.
# If no such file is available, output "".
# An example of a metadata file is a .torrent file.
# Use the host API for host specific queries, if needed.
##
function fileGetMetaName() {
    if [ -z "$FILE_LOCAL_TORRENT" ]; then
        echo ''
    else
        echo "`hostGetTestDir`files/$FILE_NAME/torrent.torrent"
    fi
}

##
# Output the Merkle root hash of the file.
# If no such root hash is known, output "".
##
function fileGetRootHash() {
    # Default implementation just uses FILE_ROOTHASH
    fileGetRootHash__default
}

##
# This function returns the API version implemented in this object.
# You should always leave this number in tact, unless you have upgraded the module to another version.
# This version number is used to check compatibilities with the core.
#
# @output   The API version number.
##
function fileAPIVersion() {
    echo "1.0.0"
}
