#!/bin/bash

#
# Implementation of the file API for a local file or directory.
# This file module supports these extra parameters:
# - path                The path to the actual file or directory on the local machine
# - torrent             Set this to "yes" to have a torrent file automatically generated from the file; the torrent file will be uploaded and its location available through fileGetMetaName. The metaFile parameter must not be set in this case.
# - generateRootHash    Set this to "yes" to have the SHA1 root hash automatically generated from the file; the rootHash parameter must not be set in this case. path must refer to a file for a root hash to be calculated.
# - renameFile          Set this to "yes" to have the file renamed when uploaded to an automatically generated name. This is forbidden when automated torrent generation is requested. Not valid if path points to a directory.
#

##
# Read settings from the provided settings file and save them to ${LOCAL_TEST_DIR}/files/$FILE_NAME .
# Please return false (non-0) when an error occurs, instead of calling fail.
# The way the settings are saved into ${LOCAL_TEST_DIR}/files/$FILE_NAME/ does not matter, but make sure it exists and that ${LOCAL_TEST_DIR}/files/$FILE_NAME/modulename contains the module subtype and nothing else.
#
# @param    The settings file to read from.
# @param    The line number at which this file object was defined. The first line in the settings file is at line $(($2 + 1))
#
# @return   True (0) iff the settings were parsed and saves succesfully.
##
function fileReadSettings() {
    local parameterName=""
    local parameterValue=""
    LINE_NUMBER=$(($2 + 1))
    FILE_LOCAL_PATH=""
    FILE_LOCAL_RENAME=""
    local file_local_torrent_requested=0
    local file_local_roothash_requested=0
    # Parse all parameters
    while IFS="" read LINE; do
        if [ "" = "$LINE" ]; then
            LINE_NUMBER=$(($LINE_NUMBER + 1))
            continue
        fi
        parameterName=`getParameterName "$LINE"`
        checkFailScenarioFile "$6"
        parameterValue=`getParameterValue "$LINE"`
        # Handle this parameter appropiately
        case $parameterName in
            name|rootHash|metaFile)
                # These are the generic settings that have already been parsed. Usually one can ignore them as such.
                ;;
            path)
                if [ ! -f "$parameterValue" ]; then
                    if [ ! -d "$parameterValue" ]; then
                        logError "file:local :: Path to a file was given to file $FILE_NAME, but no such file exists: \"$parameterValue\" (line $LINE_NUMBER)."
                        return 1
                    fi
                fi
                if [ ! -z "$FILE_LOCAL_PATH" ]; then
                    logError "file:local :: File $FILE_NAME already has a path associated with it (line $LINE_NUMBER)."
                    return 1
                fi
                FILE_LOCAL_PATH="$parameterValue"
                ;;
            torrent)
                if [ "$parameterValue" = "yes" ]; then
                    if [ ! -z "$FILE_METAFILE" ]; then
                        logError "file:local :: Automated generation of a torrent file was requested, but a meta file was already given to the file in general: \"$FILE_METAFILE\". Multiple meta file are not supported."
                        return 1
                    fi
                    file_local_torrent_requested=1
                fi
                ;;
            generateRootHash)
                if [ "$parameterValue" = "yes" ]; then
                    if [ ! -z "$FILE_ROOTHASH" ]; then
                        logError "file:local :: File $FILE_NAME has a request to have the SHA1 root hash calculated, but it was already supplied: $FILE_ROOTHASH (line $LINE_NUMBER)."
                        return 1
                    fi
                    file_local_roothash_requested=1
                fi
                ;;
            renameFile)
                if [ "$parameterValue" = "yes" ]; then
                    FILE_LOCAL_RENAME="yes"
                fi
                ;;
            *)
                logError "file:local :: Unknown parameter name \"$parameterName\" in file $FILE_NAME. Ignoring."
                ;;
        esac
        LINE_NUMBER=$(($LINE_NUMBER + 1))
    done < "$1";

    if [ -z "$FILE_LOCAL_PATH" ]; then
        logError "file:local :: File $FILE_NAME has not path associated with it, but that is required for files of type 'file' (line $LINE_NUMBER)."
        return 1
    fi

    if [ -d "$FILE_LOCAL_PATH" -a "$FILE_LOCAL_RENAME" = "yes" ]; then
        logError "file:local :: File $FILE_NAME has renameFile set to \"yes\", but refers to a directory. renameFile=yes is only valid for single files."
        return 1
    fi

    # Delegate standard saving to the default implementation
    fileReadSettings__default
    # Any variables set up above should be saved like this:
    # echo "YOUR_SETTING=\"$YOUR_SETTING\"" >> "${LOCAL_TEST_DIR}/files/$FILE_NAME/conf"
    echo "FILE_LOCAL_PATH=\"$FILE_LOCAL_PATH\"" >> "${LOCAL_TEST_DIR}/files/$FILE_NAME/conf"

    # Try and create a torrent file for this single file.
    FILE_LOCAL_TORRENT=''
    if [ $file_local_torrent_requested -eq 1 ]; then
        if [ ! -z "$FILE_LOCAL_RENAME" ]; then
            logError "file:local :: Automated generation of a torrent file is requested for file $FILE_NAME, but renaming of the file is also requested. This would most likely lead to an unusable torrent file and is hence not supported."
            return 1
        fi
        loadFunctionsScript torrent.sh
        if torrentCreateFromSingleFile "$FILE_LOCAL_PATH" "${LOCAL_TEST_DIR}/files/$FILE_NAME/torrent.torrent"; then
            FILE_LOCAL_TORRENT="${LOCAL_TEST_DIR}/files/$FILE_NAME/torrent.torrent"
        else
            logError "file:local :: Could not generate the torrent file from local file \"$FILE_LOCAL_PATH\". Perhaps the file is too large?"
            return 1
        fi
    fi
    echo "FILE_LOCAL_TORRENT=\"$FILE_LOCAL_TORRENT\"" >> "${LOCAL_TEST_DIR}/files/$FILE_NAME/conf"

    # Try and calculate the roor hash for this single file.
    if [ $file_local_roothash_requested -eq 1 ]; then
        if [ -d "$FILE_LOCAL_PATH" ]; then
            logError "file:local :: Automated generation of a root hash was requested for file $FILE_NAME, but \"$FILE_PATH\" refers to a directory. Root hashes are only valid for single files."
            return 1
        fi
        loadFunctionsScript merkle.sh
        if ! merkleCanCalculate; then
            logError "file:local :: Could not generate the root hash from local file \"$FILE_LOCAL_PATH\". Perhaps the file is too large?"
            return 1
        fi
        FILE_ROOTHASH=`merkleCalculateRootHashFromSingleFile "$FILE_LOCAL_PATH"`
        if [ -z "$FILE_ROOTHASH" ]; then
            logError "file:local :: No root hash was calculated for \"$FILE_LOCAL_PATH\", although requested."
            return 1
        fi
        if ! echo "$FILE_ROOTHASH" | grep -E "[[:xdigit:]]{40}" > /dev/null; then
            logError "file:local :: A root hash seemed to have been calculated, but it does not consists of 40 hexadecimal digits, as was expected. The output of the calculation: \"$FILE_ROOTHASH\"."
            return 1
        fi
        echo "FILE_ROOTHASH=\"$FILE_ROOTHASH\"" >> "${LOCAL_TEST_DIR}/files/$FILE_NAME/conf"
    fi
    
    # Finally, register our file with the environment
    FILES="$FILES $FILE_NAME"
    return 0
}

##
# Loads previously saved settings into memory.
# Be sure to override all relevant variables, whether they're saved or not.
#
# @param    The name of the file object to be loaded.
##
function fileLoadSettings() {
    # By default delegated to the default implementation, which works fine if the default implementation for fileReadSettings is used
    fileLoadSettings__default "$1" "local"
}

##
# Send any required files to the host.
# This function will be called for each host.
# Use the host API to do the actual sending of the files.
##
function fileSendToHost() {
    hostSendCommand "mkdir -p \"`hostGetTestDir`/files/$FILE_NAME/\""
    if [ ! -z "$FILE_LOCAL_TORRENT" ]; then
        hostSendFile "$FILE_LOCAL_TORRENT" "`hostGetTestDir`/files/$FILE_NAME/torrent.torrent"
    fi

    # Default sends the meta file, if given, to `hostGetTestDir`/files/$FILE_NAME/meta/
    fileSendToHost__default
}

##
# Send any files required for seeding to the host.
# This function will be called for each host on which seeding of the file is needed.
# Note that fileSendToHost will also be called, before this function is called.
# Use the host API to do the actual sending of the files.
##
function fileSendToSeedingHost() {
    if [ -d "$FILE_LOCAL_PATH" ]; then
        hostSendCommand "mkdir -p \"`hostGetTestDir`/files/$FILE_NAME/outputDir\""
        hostSendFiles "$FILE_LOCAL_PATH" "`hostGetTestDir`/files/$FILE_NAME/outputDir"
    else
        if [ -z "$FILE_LOCAL_RENAME" ]; then
            local filename=`basename "$FILE_LOCAL_PATH"`
            hostSendCommand "mkdir -p \"`hostGetTestDir`/files/$FILE_NAME/data/\""
            hostSendFile "$FILE_LOCAL_PATH" "`hostGetTestDir`/files/$FILE_NAME/data/$filename"
        else
            hostSendFile "$FILE_LOCAL_PATH" "`hostGetTestDir`/files/$FILE_NAME/outputFile"
        fi
    fi
}

##
# Output the path to the file, or the root directory of a set of files, on the currently loaded host.
# This assumes that fileSendToHost has already been called.
# This file is only available for seeding hosts, use the execution API to verify this, if needed.
# Use the host API for host specific queries, if needed.
#
# Note that the file's name is outputFile on the remote host; this is to have an equal file name on disk as is proposed in the .torrent.
# See torrentCreateFromSingleFile.
##
function fileGetName() {
    if executionIsSeeder; then
        local filename=`basename "$FILE_LOCAL_PATH"`
        if [ -d "$FILE_LOCAL_PATH" ]; then
            echo "`hostGetTestDir`/files/$FILE_NAME/outputDir/$filename"
        else
            if [ -z "$FILE_LOCAL_RENAME" ]; then
                echo "`hostGetTestDir`/files/$FILE_NAME/data/$filename"
            else
                echo "`hostGetTestDir`/files/$FILE_NAME/outputFile"
            fi
        fi
    else
        echo ""
    fi
}

##
# Output the path to the file containing metadata on the currently loaded host.
# If no such file is available, output "".
# An example of a metadata file is a .torrent file.
# Use the host API for host specific queries, if needed.
##
function fileGetMetaName() {
    if [ -z "$FILE_LOCAL_TORRENT" ]; then
        # Default just uses FILE_METAFILE
        fileGetMetaName__default
    else
        echo "`hostGetTestDir`files/$FILE_NAME/torrent.torrent"
    fi
}

##
# Output the Merkle root hash of the file.
# If no such root hash is known, output "".
##
function fileGetRootHash() {
    # Default implementation just uses FILE_ROOTHASH
    fileGetRootHash__default
}

##
# This function returns the API version implemented in this object.
# You should always leave this number in tact, unless you have upgraded the module to another version.
# This version number is used to check compatibilities with the core.
#
# @output   The API version number.
##
function fileAPIVersion() {
    echo "1.0.4"
}
