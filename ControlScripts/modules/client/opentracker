#!/bin/bash

#
# A client implementation for the Opentracker torrent tracker software
#
# You can retrieve the Opentracker software from http://erdgeist.org/arts/software/opentracker/
# 
# The following parameters are also recognized by client:opentracker:
# - port            The port on which the tracker will be listening (required, 1023 < positive integer < 65536)
# - changetracker   The name of a file object for which the metaFile parameter has been set and points to a .torrent file; the torrent file will be changed to point to the dynamically retrieved address of the first host running this client; the file objects will be altered to have their metaFile point to the changed torrent file before the files will be uploaded; can be specified multiple times
#

##
# Read settings from the provided settings file and save them to ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME .
# Please return false (non-0) when an error occurs, instead of calling fail.
# The way the settings are saved into ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/ does not matter, but make sure it exists and that ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/modulename contains the module subtype and nothing else.
# 
# @param    The settings file to read from.
# @param    The line number at which this client object was defined. The first line in the settings file is at line $(($2 + 1))
#
# @return   True (0) iff the settings were parsed and saved succesfully.
##
function clientReadSettings() {
    local parameterName=""
    local parameterValue=""
    LINE_NUMBER=$(($2 + 1))
    CLIENT_OPENTRACKER_PORT=""
    CLIENT_OPENTRACKER_CHANGETRACKERS=""
    # Parse all parameters
    while IFS="" read LINE; do
        if [ "" = "$LINE" ]; then
            LINE_NUMBER=$(($LINE_NUMBER + 1))
            continue
        fi

        parameterName=`getParameterName "$LINE"`
        checkFailScenarioFile "$6"
        parameterValue=`getParameterValue "$LINE"`
        # Handle this parameter appropriately
        case $parameterName in
            name|params|location|parser|remoteClient|builder|source)
                # These are the generic settings that have already been parsed. Usually one can ignore them as such.
                ;;
            port)
                if [ ! -z "$CLIENT_OPENTRACKER_PORT" ]; then
                    logError "client:opentracker :: Client $CLIENT_NAME has already has its port set."
                    return 1
                fi
                if echo "$parameterValue" | grep -E "[^[:digit:]]"; then
                    logError "client:opentracker :: Invalid port for client $CLIENT_NAME: \"$parameterValue\""
                    return 1
                fi
                if [ "$parameterValue" -gt 65535 ]; then
                    logError "client:opentracker :: Invalid port for client $CLIENT_NAME: \"$parameterValue\""
                    return 1
                fi
                if [ "$parameterValue" -lt 1024 ]; then
                    logError "client:opentracker :: Refusing to use privileged port $parameterValue for client $CLIENT_NAME."
                    return 1
                fi
                CLIENT_OPENTRACKER_PORT="$parameterValue"
                ;;
            changetracker)
                if ! isValidName "$parameterValue"; then
                    logError "client:opentracker :: Client $CLIENT_NAME can't change the tracker of file \"$parameterValue\", since that isn't a valid name and hence can't refer to a valid file object."
                    return 1
                fi
                CLIENT_OPENTRACKER_CHANGETRACKERS="$CLIENT_OPENTRACKER_CHANGETRACKERS $parameterValue"
                ;;
            *)
                logError "client:opentracker :: Unknown parameter name \"$parameterName\" in client $CLIENT_NAME on line $LINE_NUMBER. Ignoring."
                ;;
        esac
        LINE_NUMBER=$(($LINE_NUMBER + 1))
    done < "$1";

    if [ -z "$CLIENT_OPENTRACKER_PORT" ]; then
        logError "client:opentracker :: port parameter is required for client $CLIENT_NAME."
        return 1
    fi

    if [ ! -z "$CLIENT_OPENTRACKER_CHANGETRACKERS" ]; then
        if [ ! -f "${TEST_ENV_DIR}/../Utils/changetracker/changetracker.py" ]; then
            logError "client:opentracker :: Client $CLIENT_NAME is instructed to change some file's tracker, but the changetracker.py script of the changetracker utility can't be found."
            return 1
        fi
        if ! which python > /dev/null 2> /dev/null; then
            logError "client:opentracker :: Client $CLIENT_NAME is instructed to change some file's tracker, but the changetracker utility requires python and \"which python\" returned non-zero."
            return 1
        fi
        if ! python "${TEST_ENV_DIR}/../Utils/changetracker/changetracker.py" > /dev/null; then
            logError "client:opentracker :: Client $CLIENT_NAME is instructed to change some file's tracker, but the changetracker.py script can't be run with python."
            return 1
        fi
    fi

    # Delegate the rest to the default implementation
    clientReadSettings__default
    # Any variables set up above should be saved like this:
    # echo "YOUR_SETTING=\"$YOUR_SETTING\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_OPENTRACKER_PORT=\"$CLIENT_OPENTRACKER_PORT\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_OPENTRACKER_CHANGETRACKERS=\"$CLIENT_OPENTRACKER_CHANGETRACKERS\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"

    # Finally, register our client with the environment
    CLIENTS="$CLIENTS $CLIENT_NAME"
    return 0
}

##
# Loads previously saved settings into memory.
# Be sure to override all relevant variables, whether they're saved or not.
#
# @param    The name of the client object to be loaded.
##
function clientLoadSettings() {
    # By default delegated to the default implementation, which works fine if the default implementation for clientReadSettings is used
    clientLoadSettings__default "$1" "opentracker"
}

##
# Run the client on the currently loaded host.
# Use the host API to execute commands for running the client and the file API for getting the right file.
# Use the execution API to find information about the specific run, such as an execution specific number.
# All necessary files are already available on the target machine.
# Be sure to take CLIENT_PARAMS into account here.
##
function clientStart() {
    # The skeleton implementation build a complete runner script in the clientPrepare function. See there for details on running the client.
    # Here said script is just called on the host.
    clientStart__default
}

##
# Return whether the client is running on the loaded host.
# Use the host API to execute commands to find out if the client is still running.
# Use the execution API to find information about the specific run, such as an execution specific number.
#
# @return   True (0) if the client is still running.
##
function clientRunning() {
    # The default implementation relies on the pid file in `hostGetTestDir`/clients/$CLIENT_NAME/pid_`executionNumber`
    if clientRunning__default; then
        return 0
    fi
    return 1
}

##
# Ends the execution of the client on the loaded host.
# Use the host API to execute commands to kill the client.
# Use the execution API to find information about the specific run, such as an execution specific number.
##
function clientKill() {
    # The default implementation relies on the pid file in `hostGetTestDir`/clients/$CLIENT_NAME/pid_`executionNumber`
    clientKill__default
}

##
# Does client specific preparation at the beginning of a scenario's run.
##
function clientPrepare() {
    # The default implementation creates the cleanup
    clientPrepare__default
}

##
# Does client/host specific preparation on the host as well as copying the files of the client to the host.
# Use the host API for sending files and executing commands.
##
function clientPrepareHost() {
    # The default implementation creates client specific directories (`hostGetTestDir`/clients/$CLIENT_NAME/ and
    # `hostGetTestDir`/logs/$CLIENT_NAME/ as well as `hostGetPersistentTestDir`/clients/$CLIENT_NAME/ and
    # `hostGetPersistenTestDir`/logs/$CLIENT_NAME/) and adds clientCleanupHost to the cleanup file.
    clientPrepareHost__default

    # Add extra preparation, such as sending the binaries of your client, here
    # As long as you place everything in the directories mentioned above, everything will be cleaned up

    if [ -z "$CLIENT_REMOTECLIENT" ]; then
        # Send your client files here
        # Note that a binary client only needs to be sent when it is not assumed to be available (or have been built) remotely
        # This also means that, even when building the client locally, the uploading of the resulting binary is still to be done here
        hostSendFile "`sourceLocalLocation`/opentracker" "`hostGetTestDir`/clients/$CLIENT_NAME/opentracker" 1
    fi

    if [ ! -z "$CLIENT_OPENTRACKER_CHANGETRACKERS" ]; then
        local filename=""
        local newTracker="`hostGetAddress`"
        if [ -z "$newTracker" ]; then
            logError "client:opentracker :: Client $CLIENT_NAME was instructed to update some file's trackers, but for that the address of the first host running the client is required. That host, however, does not return anything from hostGetAddress."
            fail
        fi
        newTracker="http://$newTracker:$CLIENT_OPENTRACKER_PORT/announce"
        for filename in $CLIENT_OPENTRACKER_CHANGETRACKERS; do
            if [ -d "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/original_files/$filename" ]; then
                # Directory already exists: the file has already had its meta file updated
                continue
            fi
            if ! mkdir -p "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/original_files/$filename"; then
                logError "client:opentracker :: Client $CLIENT_NAME tried to create a directory for original meta files of file $filename, which failed."
                fail
            fi
            if ! mkdir -p "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/updated_files/$filename"; then
                logError "client:opentracker :: Client $CLIENT_NAME tried to create a directory for updated meta files of file $filename, which failed."
                fail
            fi
            fileLoadSettings "$filename"
            if ! cp "$FILE_METAFILE" "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/original_files/$filename/"; then
                logError "client:opentracker :: Client $CLIENT_NAME could not copy the original meta file for file $filename."
                fail
            fi
            python "${TEST_ENV_DIR}/../Utils/changetracker/changetracker.py" -f "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/original_files/$filename" -w "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/updated_files/$filename" -n "$newTracker"
            local newtorrent=""
            if [ -z "`ls "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/updated_files/$filename/"*.torrent`" ]; then
                logError "client:opentracker :: Client $CLIENT_NAME was instructed to update the meta file of file $filename, but no torrent files were found in the output directory after running the changetracker utility. Is the meta file of file $filename a .torrent file?"
                fail
            fi
            for newtorrent in `ls "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/updated_files/$filename/"*.torrent`; do
                break
            done
            if [ ! -f "$newtorrent" ]; then
                logError "client:opentracker :: Client $CLIENT_NAME was instructed to update the meta file of file $filename. The output file seems to be \"$newtorrent\", but that can't be found."
                fail
            fi
            echo "FILE_METAFILE=\"$newtorrent\"" >> "${LOCAL_TEST_DIR}/files/$filename/conf"
        done
    fi
}

##
# Does client/execution specific preparation on the host as well as copying execution specific files of the client to the host.
# Can also build and send scripts for running the client on the host. Be sure to take CLIENT_PARAMS into account, in that case.
# Use the host API for sending files and executing commands. Use the file API for getting the right file.
# Use the execution API to find information about the specific run, such as an execution specific number.
##
function clientPrepareExecution() {
    # The default implementation wants one argument: the command line to run your client.
    # This should either be semicolon separated only have the last command really run the (blocking) client, or be enclosed in parentheses.
    # The runner script will first cd to the build dir if a remote build is done, the remote directory if a binary client is not build and assumed to be available remotely, and the client's temporary directory on the host otherwise.
    #
    # Examples of using clientPrepare__default:
    # - clientPrepare__default  "./runMyClient"
    # - clientPrepare__default  "( ./clientPart1; ./clientPart2; ./clientCleanup )"
    #
    # Please make sure to take $CLIENT_REMOTECLIENT into account in your command line.
    #
    # When redirecting logs, please make sure you place them in hostGetPersistentTestDir, or you might not be able to download them after the client has finished executing.
    #
    # Apart from creating the runner script, the default implementation creates a number of remote directories:
    # `hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber` and `hostGetTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`
    # `hostGetPersistentTestDir`/clients/$CLIENT_NAME/exec_`executionNumber` and `hostGetPersistentTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`
    clientPrepareExecution__default "./opentracker -p $CLIENT_OPENTRACKER_PORT -P $CLIENT_OPENTRACKER_PORT"

    # The default implementation can be used to build the runner script. Do any extra execution specific preparation for your client here.
    # As long as you place thing in the directories mentioned above, everything will be cleaned up.
}

##
# Does client/execution specific cleanup.
# Use the host API for issuing commands.
##
function clientCleanupExecution() {
    # The default implementation should be called for forwards compatibility (it is currently empty)
    clientCleanupExecution__default
}

##
# Does client/host specific cleanup and removes the client from the host.
# Use the host API for issuing commands.
##
function clientCleanupHost() {
    # The default implementation removes the remotely created directories
    # As long as all your things are in the directories created by the default implementation of clientPrepareHost, the default is good for you.
    clientCleanupHost__default
}

##
# Does the final client cleanup.
# This function is called once after all execution and host specific cleanup is done.
##
function clientCleanupFinal() {
    # The default implementation removes the cleanup files
    # This is probably just fine for you
    clientCleanupFinal__default

    # Note that, because of the symmetry of this function with clientReadSettings, this functions is also called when just testing the settings for correctness.
}

##
# Retrieves the client specific logs from the host.
# The logs are to be stored in the local directory pointed to by $1
# Use the host API for retrieving the logs.
# Use the execution API to find information about the specific run, such as an execution specific number.
#
# @param    The local directory in which the logs are to be saved.
##
function clientRetrieveLogs() {
    # There are no logs from the tracker
    return
}

##
# Loads the default parser object for this client.
# This will load either the parser as defined by CLIENT_PARSER or parser:$CLIENT_SUBTYPE if the former is not defined.
##
function clientLoadDefaultParser() {
    # There really isn't any reason not to use the defaul here
    clientLoadDefaultParser__default
}

##
# Outputs the protocol used for actual traffic.
# This value is used for setting up traffic control, if desired.
# Typical values are "UDP", "TCP", etc.
#
# When a TC module finds a protocol it can't handle explicitly, or "", it will fallback to full traffic control, i.e. controlling all traffic between involved hosts.
#
# @output   The protocol used for traffic.
##
function clientTrafficProtocol() {
    echo ""
}

##
# Outputs a list of inbound ports on which all incoming traffic can be controlled.
# This list is used for setting up traffic control, if desired.
#
# This list should only be given if it is definite: the idea is that when all involved clients give such a list, the testing environment will try to set up traffic control by controlling all inbound traffic on all clients.
#
# Specify "" if no such list can be given (i.e. the program does not listen on specific ports or uses dynamic allocation of ports).
#
# The specific notation of ports depends on the protocol specified in clientTrafficProtocol.
#
# @output   The list of inbound ports that would capture all incoming traffic.
##
function clientTrafficInboundPorts() {
    echo "$CLIENT_OPENTRACKER_PORT"
}

##
# Outputs a list of outbound ports on which all outgoing traffic can be controlled.
# This list is used for setting up traffic control, if desired.
#
# This list should only be given if it is definite: the idea is that when all involved clients give such a list, the testing environment will try to set up traffic control by controlling all outbound traffic on all clients.
#
# Specify "" if no such list can be given (i.e. the program does not send from specific ports or uses dynamic allocation of ports).
#
# The specific notation of ports depends on the protocol specified in clientTrafficProtocol.
#
# @output   The list of outbound ports that would capture all outgoing traffic.
##
function clientTrafficOutboundPorts() {
    echo "$CLIENT_OPENTRACKER_PORT"
}

##
# This function returns the API version implemented in this object.
# You should always leave this number in tact, unless you have upgraded the module to another version.
# This version number is used to check compatibilities with the core.
#
# @output   The API version number.
##
function clientAPIVersion() {
    echo "1.0.3"
}
