#!/bin/bash

#
# Implementation of the client API for the default (i.e. Grishchenko's branch) swift command line client.
#
# The swift client supports these extra parameters:
# - listenAddress   Which address to listen on (i.e. --listen to swift, together with listenPort)
# - listenPort      Which port to list on (i.e. --listen on swift, together with listenAddress)
# - tracker         Specifies a tracker address (i.e. --tracker to swift); the tracker may be specified as @name or @name:port to load host hostname inside the testing framework after all hosts have been prepared, and use that host's address.
# - wait            Specifies the number of seconds to wait (i.e. --wait to swift in seconds)
#
# The libswift client will require --wait for seeders. By default it is set to 900s for seeders.
#
# Example using dynamic tracker addressing:
#
#   [host:ssh]
#   name=yourSeeder
#   hostname=seeder.host.org
#
#   [client:swift]
#   name=leeching_swift_client
#   tracker=@yourSeeder:2000
#
# This will have all instances of leeching_swift_client use yourSeeder as its tracker, whatever the used address for that host may be.
# This function is extremely useful in combination with hosts like das4, for which the address of the host isn't known ahead.
#

##
# Read settings from the provided settings file and save them to ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME .
# Please return false (non-0) when an error occurs, instead of calling fail.
# The way the settings are saved into ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/ does not matter, but make sure it exists and that ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/modulename contains the module subtype and nothing else.
# 
# @param    The settings file to read from.
# @param    The line number at which this client object was defined. The first line in the settings file is at line $(($2 + 1))
#
# @return   True (0) iff the settings were parsed and saved succesfully.
##
function clientReadSettings() {
    local parameterName=""
    local parameterValue=""
    LINE_NUMBER=$(($2 + 1))
    CLIENT_SWIFT_LISTEN=""
    CLIENT_SWIFT_LISTENPORT=""
    CLIENT_SWIFT_TRACKER=""
    CLIENT_SWIFT_WAIT=""
    # Parse all parameters
    while IFS="" read LINE; do
        if [ "" = "$LINE" ]; then
            LINE_NUMBER=$(($LINE_NUMBER + 1))
            continue
        fi

        parameterName=`getParameterName "$LINE"`
        checkFailScenarioFile "$6"
        parameterValue=`getParameterValue "$LINE"`
        # Handle this parameter appropriately
        case $parameterName in
            name|params|location|parser|remoteClient|builder|source)
                # These are the generic settings that have already been parsed. Usually one can ignore them as such.
                ;;
            listenAddress)
                if echo "$parameterValue" | grep "[[:space:]]" > /dev/null; then
                    logError "client:swift :: The listenAddress parameter to a swift client may not contain spaces (line $LINE_NUMBER)"
                    return 1
                fi
                CLIENT_SWIFT_LISTEN="$parameterValue"
                ;;
            listenPort)
                if echo "$parameterValue" | grep "[[:space:]]" > /dev/null; then
                    logError "client:swift :: The listenPort parameter to a swift client may not contain spaces (line $LINE_NUMBER)"
                    return 1
                fi
                CLIENT_SWIFT_LISTENPORT="$parameterValue"
                ;;
            tracker)
                if echo "$parameterValue" | grep "[[:space:]]" > /dev/null; then
                    logError "client:swift :: The tracker parameter to a swift client may not contain spaces (line $LINE_NUMBER)"
                    return 1
                fi
                CLIENT_SWIFT_TRACKER="$parameterValue"
                ;;
            wait)
                if ! echo "$parameterValue" | grep -E "^[[:digit:]]*$" > /dev/null; then
                    logError "client:swift :: The wait parameter to a swift client may only contain numbers (line $LINE_NUMBER)"
                    return 1
                fi
                CLIENT_SWIFT_WAIT="${parameterValue}s"
                ;;
            *)
                logError "client:swift :: Unknown parameter name \"$parameterName\" in client $CLIENT_NAME on line $LINE_NUMBER. Ignoring."
                ;;
        esac
        LINE_NUMBER=$(($LINE_NUMBER + 1))
    done < "$1";

    if [ ! -z "$CLIENT_SWIFT_LISTENPORT" ]; then
        CLIENT_SWIFT_LISTEN="${CLIENT_SWIFT_LISTEN}:${CLIENT_SWIFT_LISTENPORT}"
    fi

    # Delegate the rest to the default implementation
    clientReadSettings__default
    # Any variables set up above should be saved like this:
    # echo "YOUR_SETTING=\"$YOUR_SETTING\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_SWIFT_LISTEN=\"$CLIENT_SWIFT_LISTEN\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_SWIFT_LISTENPORT=\"$CLIENT_SWIFT_LISTENPORT\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_SWIFT_TRACKER=\"$CLIENT_SWIFT_TRACKER\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_SWIFT_WAIT=\"$CLIENT_SWIFT_WAIT\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"

    # Finally, register our client with the environment
    CLIENTS="$CLIENTS $CLIENT_NAME"
    return 0
}

##
# Loads previously saved settings into memory.
# Be sure to override all relevant variables, whether they're saved or not.
#
# @param    The name of the client object to be loaded.
##
function clientLoadSettings() {
    # By default delegated to the default implementation, which works fine if the default implementation for clientReadSettings is used
    clientLoadSettings__default "$1" "swift"
}

##
# Run the client on the currently loaded host.
# Use the host API to execute commands for running the client and the file API for getting the right file.
# Use the execution API to find information about the specific run, such as an execution specific number.
# All necessary files are already available on the target machine.
# Be sure to take CLIENT_PARAMS into account here.
##
function clientStart() {
    # The skeleton implementation build a complete runner script in the clientPrepare function. See there for details on running the client.
    # Here said script is just called on the host.
    clientStart__default
}

##
# Return whether the client is running on the loaded host.
# Use the host API to execute commands to find out if the client is still running.
# Use the execution API to find information about the specific run, such as an execution specific number.
#
# @return   True (0) if the client is still running.
##
function clientRunning() {
    # The default implementation relies on the pid file in `hostGetTestDir`/clients/$CLIENT_NAME/pid_`executionNumber`
    if clientRunning__default; then
        return 0
    fi
    return 1
}

##
# Ends the execution of the client on the loaded host.
# Use the host API to execute commands to kill the client.
# Use the execution API to find information about the specific run, such as an execution specific number.
##
function clientKill() {
    # The default implementation relies on the pid file in `hostGetTestDir`/clients/$CLIENT_NAME/pid_`executionNumber`
    clientKill__default
}

##
# Does client specific preparation at the beginning of a scenario's run.
##
function clientPrepare() {
    # The default implementation creates the cleanup
    clientPrepare__default
}

##
# Does client/host specific preparation on the host as well as copying the files of the client to the host.
# Use the host API for sending files and executing commands.
##
function clientPrepareHost() {
    # The default implementation creates client specific directories (`hostGetTestDir`/clients/$CLIENT_NAME/ and
    # `hostGetTestDir`/logs/$CLIENT_NAME/ as well as `hostGetPersistentTestDir`/clients/$CLIENT_NAME/ and
    # `hostGetPersistenTestDir`/logs/$CLIENT_NAME/) and adds clientCleanupHost to the cleanup file.
    clientPrepareHost__default

    # Add extra preparation, such as sending the binaries of your client, here
    # As long as you place everything in the directories mentioned above, everything will be cleaned up

    if [ -z "$CLIENT_REMOTECLIENT" ]; then
        # Send the client to the host
        hostSendFile "`sourceLocalLocation`/swift" "`hostGetTestDir`/clients/$CLIENT_NAME/swift" 1
    fi
}

##
# Does client/execution specific preparation on the host as well as copying execution specific files of the client to the host.
# Can also build and send scripts for running the client on the host. Be sure to take CLIENT_PARAMS into account, in that case.
# Use the host API for sending files and executing commands. Use the file API for getting the right file.
# Use the execution API to find information about the specific run, such as an execution specific number.
##
function clientPrepareExecution() {
    # Prepare arguments to the swift client
    local args=""
    if executionIsSeeder; then
        args="--file `fileGetName`"
        if [ "$CLIENT_SWIFT_WAIT" == "" ]; then
            CLIENT_SWIFT_WAIT="900s"
        fi
    else
        local roothash=`fileGetRootHash`
        if ! echo "$roothash" | grep -E "[[:xdigit:]]{40}" > /dev/null; then
            logError "client:swift :: The swift client is to be downloading, but the root hash returned by file $FILE_NAME is not a valid roothash: \"$roothash\" (it should consist of 40 hex digits)."
            fail
        fi
        args="--hash `fileGetRootHash` --file \"`hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber`/outputFile\""
    fi
    if [ "$CLIENT_SWIFT_WAIT" != "" ]; then
        args="$args --wait $CLIENT_SWIFT_WAIT"
    fi
    if [ "$CLIENT_SWIFT_LISTEN" != "" ]; then
        args="$args --listen $CLIENT_SWIFT_LISTEN"
    fi
    if [ "$CLIENT_SWIFT_TRACKER" != "" ]; then
        local theTracker="$CLIENT_SWIFT_TRACKER"
        if echo "$CLIENT_SWIFT_TRACKER" | grep -E "^@" > /dev/null; then
            local myhost="$HOST_NAME"
            local indirecthost=`echo "$CLIENT_SWIFT_TRACKER" | sed -e "s/^@\([^:]*\)\(:.*\)\?$/\\1/"`
            local thePort=`echo "$CLIENT_SWIFT_TRACKER" | sed -e "s/^@\([^:]*\)\(:.*\)\?$/\\2/"`
            echo "Tracker: $CLIENT_SWIFT_TRACKER; indirecthost: $indirecthost; thePort: $thePort; myhost: $myhost" >&2
            hostLoadSettings "$indirecthost"
            if [ "$HOST_NAME" != "$indirecthost" ]; then
                logError "client:swift :: Host $indirecthost was specified as indirect tracker host for client $CLIENT_NAME, but can't be loaded."
                fail
            fi
            if [ -z "`hostGetAddress`" ]; then
                logError "client:swift :: Host $indirecthost was specified as indirect tracker host for client $CLIENT_NAME, but can't specify its address."
                fail
            fi
            theTracker="`hostGetAddress`$thePort"
            hostLoadSettings "$myhost"
        fi
        args="$args --tracker $theTracker"
    fi
    if [ "$CLIENT_PARAMS" != "" ]; then
        args="$args $CLIENT_PARAMS"
    fi

    # The default implementation wants one argument: the command line to run your client.
    # This should either be semicolon separated only have the last command really run the (blocking) client, or be enclosed in parentheses.
    # The runner script will first cd to the build dir if a remote build is done, the remote directory if a binary client is not build and assumed to be available remotely, and the client's temporary directory on the host otherwise.
    #
    # Examples of using clientPrepare__default:
    # - clientPrepare__default  "./runMyClient"
    # - clientPrepare__default  "( ./clientPart1; ./clientPart2; ./clientCleanup )"
    #
    # When redirecting logs, please make sure you place them in hostGetPersistentTestDir, or you might not be able to download them after the client has finished executing.
    #
    # Apart from creating the runner script, the default implementationcreates a number of remote directories:
    # `hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber` and `hostGetTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`
    # `hostGetPersistentTestDir`/clients/$CLIENT_NAME/exec_`executionNumber` and `hostGetPersistentTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`
    clientPrepareExecution__default "LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:. ./swift --progress $args 2> \"`hostGetPersistentTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`/log.log\""

    # The default implementation can be used to build the runner script. Do any extra execution specific preparation for your client here.
    # As long as you place thing in the directories mentioned above, everything will be cleaned up.
}

##
# Does client/execution specific cleanup.
# Use the host API for issuing commands.
##
function clientCleanupExecution() {
    # The default implementation should be called for forwards compatibility (it is currently empty)
    clientCleanupExecution__default
}

##
# Does client/host specific cleanup and removes the client from the host.
# Use the host API for issuing commands.
##
function clientCleanupHost() {
    # The default implementation removes the remotely created directories
    # As long as all your things are in the directories created by the default implementation of clientPrepareHost, the default is good for you.
    clientCleanupHost__default
}

##
# Does the final client cleanup.
# This function is called once after all execution and host specific cleanup is done.
##
function clientCleanupFinal() {
    # The default implementation removes the cleanup files
    # This is probably just fine for you
    clientCleanupFinal__default
}

##
# Retrieves the client specific logs from the host.
# The logs are to be stored in the local directory pointed to by $1
# Use the host API for retrieving the logs.
# Use the execution API to find information about the specific run, such as an execution specific number.
#
# @param    The local directory in which the logs are to be saved.
##
function clientRetrieveLogs() {
    # Retrieve the logs from the host
    hostGetFile "`hostGetPersistentTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`/log.log" "$1/log.log"
}

##
# Loads the default parser object for this client.
# This will load either the parser as defined by CLIENT_PARSER or parser:$CLIENT_SUBTYPE if the former is not defined.
##
function clientLoadDefaultParser() {
    # There really isn't any reason not to use the defaul here
    clientLoadDefaultParser__default
}

##
# Outputs the protocol used for actual traffic.
# This value is used for setting up traffic control, if desired.
# Typical values are "UDP", "TCP", etc.
#
# When a TC module finds a protocol it can't handle explicitly, or "", it will fallback to full traffic control, i.e. controlling all traffic between involved hosts.
#
# @output   The protocol used for traffic.
##
function clientTrafficProtocol() {
    echo "TCP"
}

##
# Outputs a list of inbound ports on which all incoming traffic can be controlled.
# This list is used for setting up traffic control, if desired.
#
# This list should only be given if it is definite: the idea is that when all involved clients give such a list, the testing environment will try to set up traffic control by controlling all inbound traffic on all clients.
#
# Specify "" if no such list can be given (i.e. the program does not listen on specific ports or uses dynamic allocation of ports).
#
# The specific notation of ports depends on the protocol specified in clientTrafficProtocol.
#
# @output   The list of inbound ports that would capture all incoming traffic.
##
function clientTrafficInboundPorts() {
    echo "$CLIENT_SWIFT_LISTENPORT"
}

##
# Outputs a list of outbound ports on which all outgoing traffic can be controlled.
# This list is used for setting up traffic control, if desired.
#
# This list should only be given if it is definite: the idea is that when all involved clients give such a list, the testing environment will try to set up traffic control by controlling all outbound traffic on all clients.
#
# Specify "" if no such list can be given (i.e. the program does not send from specific ports or uses dynamic allocation of ports).
#
# The specific notation of ports depends on the protocol specified in clientTrafficProtocol.
#
# @output   The list of outbound ports that would capture all outgoing traffic.
##
function clientTrafficOutboundPorts() {
    echo "$CLIENT_SWIFT_LISTENPORT"
}

##
# This function returns the API version implemented in this object.
# You should always leave this number in tact, unless you have upgraded the module to another version.
# This version number is used to check compatibilities with the core.
#
# @output   The API version number.
##
function clientAPIVersion() {
    echo "1.0.3"
}
