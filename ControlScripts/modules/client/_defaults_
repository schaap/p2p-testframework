#!/bin/bash

#
# The default implementations for the client API.
# Module implementors can copy these functions if they really wish to change them, or just call them if needed.
# Whenever copying, please do NOT overwrite the default implementations, but just the actual API function.
#

##
# Returns the API version of this defaults file.
# This function should not be used by implementations!
#
# @output   The API version
##
function clientAPIVersion__default() {
    echo "1.0.0"
}

##
# Read settings from the provided settings file and save them to ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME .
# This default implementation just writes all the default parameters to "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
##
function clientReadSettings__default() {
    # Setup a cleanup file for this client
    addCleanupScript
    CLIENT_CLEANUPIDX=$?
    addCleanupCommand ". \"${TEST_ENV_DIR}/modules/client/$CLIENT_SUBTYPE\"" $CLIENT_CLEANUPIDX

    mkdir -p "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/"
    echo -n "$CLIENT_SUBTYPE" > "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/modulename"
        
    # Save all settings, including the generic ones, to a file
    # Easiest is just a bash script that sets all variables, but anything is allowed as long as ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME is created and ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/modulename contains the module subtype.
    echo "#!/bin/bash" > "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_NAME=\"$CLIENT_NAME\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_PARAMS=\"$CLIENT_PARAMS\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_SUBTYPE=\"$CLIENT_SUBTYPE\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_CLEANUPIDX=\"$CLIENT_CLEANUPIDX\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_LOCATION=\"$CLIENT_LOCATION\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_PARSER=\"$CLIENT_PARSER\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_REMOTECLIENT=\"$CLIENT_REMOTECLIENT\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_BUILDER=\"$CLIENT_BUILDER\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_SOURCE=\"$CLIENT_SOURCE\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"

    addCleanupCommand "clientLoadSettings \"$CLIENT_NAME\"" $CLIENT_CLEANUPIDX

    loadModule "source/_defaults_"
    loadModule "source/$CLIENT_SOURCE"
    loadModule "builder/_defaults_"
    loadModule "builder/$CLIENT_BUILDER"

    # Build the client if it is to be built locally
    if [ -z "$CLIENT_REMOTECLIENT" ]; then
        if [ "$CLIENT_BUILDER" != "none" ]; then
            # Only say we're compiling, if we're actually going to build
            echo "Locally compiling client $CLIENT_NAME"
        fi
        # Prepare source
        if ! sourcePrepareLocal; then
            logError "client:_defaults_ :: The source of client $CLIENT_NAME could not be prepared locally for host $HOST_NAME."
            fail
        fi
        # Build the source
        if ! builderBuildLocal `sourceLocalLocation`; then
            logError "client:_defaults_ :: A local build of client $CLIENT_NAME for host $HOST_NAME has failed."
            fail
        fi
    fi
}

##
# Loads previously saved settings into memory by loading "${LOCAL_TEST_DIR}/clients/$1/conf"
# Checks "${LOCAL_TEST_DIR}/clients/$1/modulename" against "$2" to be sure the correct module type will be loaded and offloads to the correct module is needed
#
# This default implementation complements the default implementation for clientReadSettings
#
# @param    The name of the client object to be loaded.
# @param    The name of this module subtype
##
function clientLoadSettings__default() {
    if [ ! -d "${LOCAL_TEST_DIR}/clients/$1" ]; then
        logError "client:_defaults_ :: Can't load settings for client $1"
        fail
    fi
    if [ `cat "${LOCAL_TEST_DIR}/clients/$1/modulename"` != "$2" ]; then
        function clientAPIVersion() {
            echo "wrong"
        }
        loadModule client/`cat "${LOCAL_TEST_DIR}/clients/$1/modulename"`
        if [ "`clientAPIVersion`" != `clientAPIVersion__default` ]; then
            logError "client:_defaults_ :: API version mismatch: the core expects API version `clientAPIVersion__default` but module client:`cat "${LOCAL_TEST_DIR}/clients/$1/modulename"` seems to have API version `clientAPIVersion`."
            fail
        fi
        clientLoadSettings $1
        return
    fi
    . "${LOCAL_TEST_DIR}/clients/$1/conf"
    loadModule "source/_defaults_"
    loadModule "source/$CLIENT_SOURCE"
    loadModule "builder/_defaults_"
    loadModule "builder/$CLIENT_BUILDER"
}

##
# Run the client on the currently loaded host.
# The default implementation just calls the client runner script "`hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber`/clientRunnerScript"
# See clientPrepare for details.
##
function clientStart__default() {
    # The skeleton implementation build a complete runner script in the clientPrepare function. See there for details on running the client.
    # Here said script is just called on the host.
    hostSendCommand "`hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber`/clientRunnerScript"
}

##
# Return whether the client is running on the loaded host.
# This default implementation relies on the pid file being created in `hostGetTestDir`/clients/$CLIENT_NAME/pid_`executionNumber`
#
# @return   True (0) if the client is still running.
##
function clientRunning__default() {
    # kill -0 sends no signal to the process, but does do error checking. If the process does not exist this test fails, otherwise is succeeds.
    # This test relies on the pid file created in clientStart
    local pidfile="\`cat `hostGetTestDir`/clients/$CLIENT_NAME/pid_`executionNumber` 2>/dev/null\`"
    local ret=`hostSendCommand "kill -0 $pidfile 2>/dev/null && echo -n OK"`
    if [ "$ret" = "OK" ]; then
        return 0
    fi
    return 1
}

##
# Ends the execution of the client on the loaded host.
# This default implementation relies on the pid file being created in `hostGetTestDir`/clients/$CLIENT_NAME/pid_`executionNumber`
##
function clientKill__default() {
    local pidfile="\`cat `hostGetTestDir`/clients/$CLIENT_NAME/pid_`executionNumber` 2>/dev/null\`"
    # for the kill -0 test: see clientRunning
    # This script tries several times to kill the process, each time giving the process some time. This is considered a nice way of killing, rather than just using the shotgun method (kill -9).
    # The first time a simple SIGTERM is used, to tell the process to shut down. The process is given 30 seconds to do so.
    # If that doesn't work, SIGINT is tries twice, giving 5 seconds after each try.
    # If that fails as well SIGKILL is sent.
    local killScript=`cat <<EOF
    (
        kill -0 $pidfile 2> /dev/null || exit
        kill -TERM $pidfile

        sleep 1
        kill -0 $pidfile 2> /dev/null || exit
        sleep 1
        kill -0 $pidfile 2> /dev/null || exit
        sleep 1
        kill -0 $pidfile 2> /dev/null || exit
        sleep 2
        kill -0 $pidfile 2> /dev/null || exit
        sleep 5
        kill -0 $pidfile 2> /dev/null || exit
        sleep 5
        kill -0 $pidfile 2> /dev/null || exit
        sleep 5
        kill -0 $pidfile 2> /dev/null || exit
        sleep 5
        kill -0 $pidfile 2> /dev/null || exit
        sleep 5
        kill -0 $pidfile 2> /dev/null || exit

        kill -INT $pidfile
        sleep 5
        kill -0 $pidfile 2> /dev/null || exit
        kill -INT $pidfile
        sleep 5
        kill -0 $pidfile 2> /dev/null || exit
        kill -KILL $pidfile
    ) &
wait
EOF`
    hostSendCommand "$killScript"
}

##
# Does client/host specific preparation on the host as well as copying the file of the client to the host.
# The default implementation creates client specific directories on the host
# (`hostGetTestDir`/clients/$CLIENT_NAME/ and `hostGetTestDir`/logs/$CLIENT_NAME/)
# Client cleanup is extended with cleanup for this host.
##
function clientPrepareHost__default() {
    # Make sure the cleanup is called on failure, as well as the running client is killed
    addCleanupCommand "hostLoadSettings $HOST_NAME" $CLIENT_CLEANUPIDX
    addCleanupCommand "clientKill" $CLIENT_CLEANUPIDX
    addCleanupCommand "clientCleanupHost" $CLIENT_CLEANUPIDX

    # Create client specific directories on host
    hostSendCommand "mkdir -p \"`hostGetTestDir`/clients/$CLIENT_NAME/\"; mkdir -p \"`hostGetTestDir`/logs/$CLIENT_NAME/\""

    # Build the client if a remote build is requested
    if [ ! -z "$CLIENT_REMOTECLIENT" ]; then
        if [ "$CLIENT_BUILDER" != "none" ]; then
            # Only say we're compiling if we're actually going to build
            echo "Remotely compiling client $CLIENT_NAME"
        fi
        # Prepare source
        if ! sourcePrepareRemote; then
            logError "client:_defaults_ :: The source of client $CLIENT_NAME could not be prepared remotely for host $HOST_NAME."
            fail
        fi
        # Build the source
        if ! builderBuildRemote `sourceRemoteLocation`; then
            logError "client:_defaults_ :: A local build of client $CLIENT_NAME for host $HOST_NAME has failed."
            fail
        fi
    fi
}

##
# Does client/execution specific preparation on the host as well as copying execution specific files of the client to the host.
# The default implementation creates client/execution specific directories on the host
# (`hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber` and `hostGetTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`)
# A client runner script is created. For this the argument is used.
# The runner script will first cd to the build dir if a remote build is done, the remote directory if a binary client is not build and assumed to be available remotely, and the client's temporary directory on the host otherwise.
#
# Examples of using clientPrepare__default:
# - clientPrepare__default  "./runMyClient"
# - clientPrepare__default  "( ./clientPart1; ./clientPart2; ./clientCleanup )"
#
# @param    The command line to be executed on the host to run the client. This should either be semicolon separated only have the last command really run the (blocking) client, or be enclosed in parentheses.
##
function clientPrepareExecution__default() {
    # Create client/execution specific directories on host
    hostSendCommand "mkdir -p \"`hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber`/\"; mkdir -p \"`hostGetTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`/\""
        
    # Build and send the command script for running the client
    local clientRunnerScript=`createTempFile`
    # This script, that will be run on the server, basically does this:
    # - Enable job control (essential for getting the background process back to the foreground)
    # - Create a new process in which your command line is run, and run that in the background
    # - Take the process ID of that process and write it to a file
    # - Bring your process to the foreground
    # - Make sure the process has ended before continuing (and prevent the 'enter-needed-after-background-processes-in-script' nuisance)
    # It would be best to replace the part ($COMMANDLINE) altogether with the command to run your client, so the process ID stored in the file is
    # the process ID of your running client, not of a wrapping shell process around your client.
    local remoteClientDir="`hostGetTestDir`/clients/$CLIENT_NAME/"
    if [ ! -z "$CLIENT_REMOTECLIENT" ]; then
        loadModule "source/_defaults_"
        loadModule "source/$CLIENT_SOURCE"
        remoteClientDir="`sourceRemoteLocation`"
    fi
    cat > "$clientRunnerScript" <<EOF
set -o monitor
cd "$remoteClientDir"
$1 &
echo -n \$! > `hostGetTestDir`/clients/$CLIENT_NAME/pid_`executionNumber`
%1
wait
EOF
    chmod +x "$clientRunnerScript"
    hostSendFile "$clientRunnerScript" "`hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber`/clientRunnerScript"
    rm -f "$clientRunnerScript"
}

##
# Does client/execution specific cleanup and removes the client from the host.
# Default implementation is empty.
##
function clientCleanupExecution__default() {
    return # Why return? Because an empty body does not exist in bash
}

##
# Does client/host specific cleanup and removes the client from the host.
# The default implementation simply removes the remotely created client specific directories.
##
function clientCleanupHost__default() {
    # Remove the client specific directories
    hostSendCommand "rm -rf \"`hostGetTestDir`/clients/$CLIENT_NAME\" \"`hostGetTestDir`/logs/$CLIENT_NAME\""
}

##
# Does the final client cleanup.
# The default implementation just removes the cleanup script.
##
function clientCleanupFinal__default() {
    # Remove client cleanup script: even on failure we have already cleaned up
    removeCleanupScript $CLIENT_CLEANUPIDX
    CLIENT_CLEANUPIDX=""
    echo "CLIENT_CLEANUPIDX=\"\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
}    

##
# Retrieves the client specific logs from the host.
# The logs are to be stored in the local directory pointed to by $1
# No default implementation.
#
# @param    The local directory in which the logs are to be saved.
##
#function clientRetrieveLogs() {
#}

##
# Loads the default parser object for this client.
# This will load either the parser as defined by CLIENT_PARSER or parser:$CLIENT_SUBTYPE if the former is not defined.
##
function clientLoadDefaultParser__default() {
    if [ ! -z ${CLIENT_PARSER} ]; then
        parserLoadSettings "${CLIENT_PARSER}"
    else
        loadModule "parser/${CLIENT_SUBTYPE}"
        parserLoadDefaultSettings
    fi
}
