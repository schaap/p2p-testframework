#!/bin/bash

#
# utorrent implementation for the client API
#
# This client requires the ClientWrappers/utorrent and ClientWrappers/utorrent-windows scripts.
#
# Supported extra options:
# - useWine     If set to "yes" this will instruct client:utorrent to use the windows client under wine. Note that this requires the user to make sure wine and xvfb-run function correctly with wine on the target hosts!
#
# NOTE: Do not try to run multiple utorrent instances on the same host!
# utorrent will ban instances on the same host, leading to no connectivity between the two
#

##
# Read settings from the provided settings file and save them to ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME .
# Please return false (non-0) when an error occurs, instead of calling fail.
# The way the settings are saved into ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/ does not matter, but make sure it exists and that ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/modulename contains the module subtype and nothing else.
# 
# @param    The settings file to read from.
# @param    The line number at which this client object was defined. The first line in the settings file is at line $(($2 + 1))
#
# @return   True (0) iff the settings were parsed and saved succesfully.
##
function clientReadSettings() {
    local parameterName=""
    local parameterValue=""
    LINE_NUMBER=$(($2 + 1))
    CLIENT_UTORRENT_WINE=0
    # Parse all parameters
    while IFS="" read LINE; do
        if [ "" = "$LINE" ]; then
            LINE_NUMBER=$(($LINE_NUMBER + 1))
            continue
        fi

        parameterName=`getParameterName "$LINE"`
        checkFailScenarioFile "$6"
        parameterValue=`getParameterValue "$LINE"`
        # Handle this parameter appropriately
        case $parameterName in
            name|params|location|parser|remoteClient|builder|source)
                # These are the generic settings that have already been parsed. Usually one can ignore them as such.
                ;;
            useWine)
                if [ "$parameterValue" = "yes" ]; then
                    CLIENT_UTORRENT_WINE=1
                fi
                ;;
            *)
                logError "client:utorrent :: Unknown parameter name \"$parameterName\" in client $CLIENT_NAME on line $LINE_NUMBER. Ignoring."
                ;;
        esac
        LINE_NUMBER=$(($LINE_NUMBER + 1))
    done < "$1";

    # Sanity check: do we have the extra script?
    if [ ! -f "${TEST_ENV_DIR}/../ClientWrappers/utorrent/ut_server_logging" ]; then
        logError "client:utorrent :: The wrapper script doesn't seem to be available. This script is required for this client."
        return 1
    fi

    # Delegate the rest to the default implementation
    clientReadSettings__default
    # Any variables set up above should be saved like this:
    # echo "YOUR_SETTING=\"$YOUR_SETTING\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"
    echo "CLIENT_UTORRENT_WINE=\"$CLIENT_UTORRENT_WINE\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"

    # Finally, register our client with the environment
    CLIENTS="$CLIENTS $CLIENT_NAME"
    return 0
}

##
# Loads previously saved settings into memory.
# Be sure to override all relevant variables, whether they're saved or not.
#
# @param    The name of the client object to be loaded.
##
function clientLoadSettings() {
    # By default delegated to the default implementation, which works fine if the default implementation for clientReadSettings is used
    clientLoadSettings__default "$1" "utorrent"
}

##
# Run the client on the currently loaded host.
# Use the host API to execute commands for running the client and the file API for getting the right file.
# Use the execution API to find information about the specific run, such as an execution specific number.
# All necessary files are already available on the target machine.
# Be sure to take CLIENT_PARAMS into account here.
##
function clientStart() {
    # The skeleton implementation build a complete runner script in the clientPrepare function. See there for details on running the client.
    # Here said script is just called on the host.
    clientStart__default
}

##
# Return whether the client is running on the loaded host.
# Use the host API to execute commands to find out if the client is still running.
# Use the execution API to find information about the specific run, such as an execution specific number.
#
# @return   True (0) if the client is still running.
##
function clientRunning() {
    # The default implementation relies on the pid file in `hostGetTestDir`/clients/$CLIENT_NAME/pid_`executionNumber`
    if clientRunning__default; then
        return 0
    fi
    return 1
}

##
# Ends the execution of the client on the loaded host.
# Use the host API to execute commands to kill the client.
# Use the execution API to find information about the specific run, such as an execution specific number.
##
function clientKill() {
    # The default implementation relies on the pid file in `hostGetTestDir`/clients/$CLIENT_NAME/pid_`executionNumber`
    clientKill__default
}

##
# Does client specific preparation at the beginning of a scenario's run.
##
function clientPrepare() {
    # The default implementation creates the cleanup
    clientPrepare__default
}

##
# Does client/host specific preparation on the host as well as copying the files of the client to the host.
# Use the host API for sending files and executing commands.
##
function clientPrepareHost() {
    # The default implementation creates client specific directories (`hostGetTestDir`/clients/$CLIENT_NAME/ and
    # `hostGetTestDir`/logs/$CLIENT_NAME/ as well as `hostGetPersistentTestDir`/clients/$CLIENT_NAME/ and
    # `hostGetPersistenTestDir`/logs/$CLIENT_NAME/) and adds clientCleanupHost to the cleanup file.
    clientPrepareHost__default

    # Add extra preparation, such as sending the binaries of your client, here
    # As long as you place everything in the directories mentioned above, everything will be cleaned up

    if [ $CLIENT_UTORRENT_WINE -eq 1 ]; then
        hostSendFile "${TEST_ENV_DIR}/../ClientWrappers/utorrent-windows/ut_server_logging" "`hostGetTestDir`/clients/$CLIENT_NAME/ut_server_logging" 1
    else
        hostSendFile "${TEST_ENV_DIR}/../ClientWrappers/utorrent/ut_server_logging" "`hostGetTestDir`/clients/$CLIENT_NAME/ut_server_logging" 1
    fi

    # TODO
    if [ -z "$CLIENT_REMOTECLIENT" ]; then
        # Send your client files here
        # Note that a binary client only needs to be sent when it is not assumed to be available (or have been built) remotely
        # This also means that, even when building the client locally, the uploading of the resulting binary is still to be done here

        hostSendFile "${CLIENT_LOCATION}/webui.zip" "`hostGetTestDir`/clients/$CLIENT_NAME/webui.zip" 1
        if [ $CLIENT_UTORRENT_WINE -eq 1 ]; then
            hostSendFile "${CLIENT_LOCATION}/utserver" "`hostGetTestDir`/clients/$CLIENT_NAME/utserver" 1
        else
            hostSendFile "${CLIENT_LOCATION}/utorrent.exe" "`hostGetTestDir`/clients/$CLIENT_NAME/utorrent.exe" 1
            hostSendFile "${CLIENT_LOCATION}/settings.dat" "`hostGetTestDir`/clients/$CLIENT_NAME/settings.dat" 1
        fi
    fi
}

##
# Does client/execution specific preparation on the host as well as copying execution specific files of the client to the host.
# Can also build and send scripts for running the client on the host. Be sure to take CLIENT_PARAMS into account, in that case.
# Use the host API for sending files and executing commands. Use the file API for getting the right file.
# Use the execution API to find information about the specific run, such as an execution specific number.
##
function clientPrepareExecution() {
    # The default implementation wants one argument: the command line to run your client.
    # This should either be semicolon separated only have the last command really run the (blocking) client, or be enclosed in parentheses.
    # The runner script will first cd to the build dir if a remote build is done, the remote directory if a binary client is not build and assumed to be available remotely, and the client's temporary directory on the host otherwise.
    #
    # Examples of using clientPrepare__default:
    # - clientPrepare__default  "./runMyClient"
    # - clientPrepare__default  "( ./clientPart1; ./clientPart2; ./clientCleanup )"
    #
    # Please make sure to take $CLIENT_REMOTECLIENT into account in your command line.
    #
    # When redirecting logs, please make sure you place them in hostGetPersistentTestDir, or you might not be able to download them after the client has finished executing.
    #
    # Apart from creating the runner script, the default implementation creates a number of remote directories:
    # `hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber` and `hostGetTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`
    # `hostGetPersistentTestDir`/clients/$CLIENT_NAME/exec_`executionNumber` and `hostGetPersistentTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`
    local SEEDFILE=""
    if [ ! -z "$EXECUTION_SEEDER" ]; then
        SEEDFILE="`fileGetName`"
    fi

    local TORRENTFILE="`fileGetMetaName`"
    if [ -z "$TORRENTFILE" ]; then
        logError "client:utorrent :: Client $CLIENT_NAME is supposed to be seeding file $FILE_NAME, but the latter won't give a torrent file."
        fail
    fi

    clientPrepareExecution__default "LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:~/lib `hostGetTestDir`/clients/$CLIENT_NAME/ut_server_logging `hostGetTestDir`/clients/$CLIENT_NAME `hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber` $TORRENTFILE $SEEDFILE > `hostGetPersistentTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`/log.log"

    # The default implementation can be used to build the runner script. Do any extra execution specific preparation for your client here.
    # As long as you place thing in the directories mentioned above, everything will be cleaned up.
}

##
# Does client/execution specific cleanup.
# Use the host API for issuing commands.
##
function clientCleanupExecution() {
    # The default implementation should be called for forwards compatibility (it is currently empty)
    clientCleanupExecution__default
}

##
# Does client/host specific cleanup and removes the client from the host.
# Use the host API for issuing commands.
##
function clientCleanupHost() {
    # The default implementation removes the remotely created directories
    # As long as all your things are in the directories created by the default implementation of clientPrepareHost, the default is good for you.
    clientCleanupHost__default
}

##
# Does the final client cleanup.
# This function is called once after all execution and host specific cleanup is done.
##
function clientCleanupFinal() {
    # The default implementation removes the cleanup files
    # This is probably just fine for you
    clientCleanupFinal__default

    # Note that, because of the symmetry of this function with clientReadSettings, this functions is also called when just testing the settings for correctness.
}

##
# Retrieves the client specific logs from the host.
# The logs are to be stored in the local directory pointed to by $1
# Use the host API for retrieving the logs.
# Use the execution API to find information about the specific run, such as an execution specific number.
#
# @param    The local directory in which the logs are to be saved.
##
function clientRetrieveLogs() {
    hostGetFile "`hostGetPersistentTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`/log.log" "$1/log.log"
}

##
# Loads the default parser object for this client.
# This will load either the parser as defined by CLIENT_PARSER or parser:$CLIENT_SUBTYPE if the former is not defined.
##
function clientLoadDefaultParser() {
    # There really isn't any reason not to use the defaul here
    clientLoadDefaultParser__default
}

##
# Outputs the protocol used for actual traffic.
# This value is used for setting up traffic control, if desired.
# Typical values are "UDP", "TCP", etc.
#
# When a TC module finds a protocol it can't handle explicitly, or "", it will fallback to full traffic control, i.e. controlling all traffic between involved hosts.
#
# @output   The protocol used for traffic.
##
function clientTrafficProtocol() {
    echo ""
}

##
# Outputs a list of inbound ports on which all incoming traffic can be controlled.
# This list is used for setting up traffic control, if desired.
#
# This list should only be given if it is definite: the idea is that when all involved clients give such a list, the testing environment will try to set up traffic control by controlling all inbound traffic on all clients.
#
# Specify "" if no such list can be given (i.e. the program does not listen on specific ports or uses dynamic allocation of ports).
#
# The specific notation of ports depends on the protocol specified in clientTrafficProtocol.
#
# @output   The list of inbound ports that would capture all incoming traffic.
##
function clientTrafficInboundPorts() {
    echo ""
}

##
# Outputs a list of outbound ports on which all outgoing traffic can be controlled.
# This list is used for setting up traffic control, if desired.
#
# This list should only be given if it is definite: the idea is that when all involved clients give such a list, the testing environment will try to set up traffic control by controlling all outbound traffic on all clients.
#
# Specify "" if no such list can be given (i.e. the program does not send from specific ports or uses dynamic allocation of ports).
#
# The specific notation of ports depends on the protocol specified in clientTrafficProtocol.
#
# @output   The list of outbound ports that would capture all outgoing traffic.
##
function clientTrafficOutboundPorts() {
    echo ""
}

##
# This function returns the API version implemented in this object.
# You should always leave this number in tact, unless you have upgraded the module to another version.
# This version number is used to check compatibilities with the core.
#
# @output   The API version number.
##
function clientAPIVersion() {
    echo "1.0.4"
}
