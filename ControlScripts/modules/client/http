#!/bin/bash

#
# lighttpd / aria2 implementation for the client.
# Note that you probably wish to use this client with precompiled binaries on the hosts, especially since the binaries come from 2 different programs.
#
# Due to the dual client setup $CLIENT_PARAMS is IGNORED.
#

##
# Read settings from the provided settings file and save them to ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME .
# Please return false (non-0) when an error occurs, instead of calling fail.
# The way the settings are saved into ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/ does not matter, but make sure it exists and that ${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/modulename contains the module subtype and nothing else.
# 
# @param    The settings file to read from.
# @param    The line number at which this client object was defined. The first line in the settings file is at line $(($2 + 1))
#
# @return   True (0) iff the settings were parsed and saved succesfully.
##
function clientReadSettings() {
    local parameterName=""
    local parameterValue=""
    LINE_NUMBER=$(($2 + 1))
    # Parse all parameters
    while IFS="" read LINE; do
        if [ "" = "$LINE" ]; then
            LINE_NUMBER=$(($LINE_NUMBER + 1))
            continue
        fi

        parameterName=`getParameterName "$LINE"`
        checkFailScenarioFile "$6"
        parameterValue=`getParameterValue "$LINE"`
        # Handle this parameter appropriately
        case $parameterName in
            name|params|location|parser|remoteClient|builder|source)
                # These are the generic settings that have already been parsed. Usually one can ignore them as such.
                ;;
            *)
                logError "client:http :: Unknown parameter name \"$parameterName\" in client $CLIENT_NAME on line $LINE_NUMBER. Ignoring."
                ;;
        esac
        LINE_NUMBER=$(($LINE_NUMBER + 1))
    done < "$1";

    # Delegate the rest to the default implementation
    clientReadSettings__default
    # Any variables set up above should be saved like this:
    # echo "YOUR_SETTING=\"$YOUR_SETTING\"" >> "${LOCAL_TEST_DIR}/clients/$CLIENT_NAME/conf"

    # Finally, register our client with the environment
    CLIENTS="$CLIENTS $CLIENT_NAME"
    return 0
}

##
# Loads previously saved settings into memory.
# Be sure to override all relevant variables, whether they're saved or not.
#
# @param    The name of the client object to be loaded.
##
function clientLoadSettings() {
    # By default delegated to the default implementation, which works fine if the default implementation for clientReadSettings is used
    clientLoadSettings__default "$1" "http"
}

##
# Run the client on the currently loaded host.
# Use the host API to execute commands for running the client and the file API for getting the right file.
# Use the execution API to find information about the specific run, such as an execution specific number.
# All necessary files are already available on the target machine.
# Be sure to take CLIENT_PARAMS into account here.
##
function clientStart() {
    # The skeleton implementation build a complete runner script in the clientPrepare function. See there for details on running the client.
    # Here said script is just called on the host.
    clientStart__default
}

##
# Return whether the client is running on the loaded host.
# Use the host API to execute commands to find out if the client is still running.
# Use the execution API to find information about the specific run, such as an execution specific number.
#
# @return   True (0) if the client is still running.
##
function clientRunning() {
    # The default implementation relies on the pid file in `hostGetTestDir`/clients/$CLIENT_NAME/pid_`executionNumber`
    if clientRunning__default; then
        return 0
    fi
    return 1
}

##
# Ends the execution of the client on the loaded host.
# Use the host API to execute commands to kill the client.
# Use the execution API to find information about the specific run, such as an execution specific number.
##
function clientKill() {
    # The default implementation relies on the pid file in `hostGetTestDir`/clients/$CLIENT_NAME/pid_`executionNumber`
    clientKill__default
}

##
# Does client specific preparation at the beginning of a scenario's run.
##
function clientPrepare() {
    # The default implementation creates the cleanup
    clientPrepare__default
}

##
# Does client/host specific preparation on the host as well as copying the files of the client to the host.
# Use the host API for sending files and executing commands.
##
function clientPrepareHost() {
    # The default implementation creates client specific directories (`hostGetTestDir`/clients/$CLIENT_NAME/ and
    # `hostGetTestDir`/logs/$CLIENT_NAME/ as well as `hostGetPersistentTestDir`/clients/$CLIENT_NAME/ and
    # `hostGetPersistenTestDir`/logs/$CLIENT_NAME/) and adds clientCleanupHost to the cleanup file.
    clientPrepareHost__default

    # Add extra preparation, such as sending the binaries of your client, here
    # As long as you place everything in the directories mentioned above, everything will be cleaned up

    hostSendFile "${TEST_ENV_DIR}/../ClientWrappers/lighttpd/lighttpd_logging" "`hostGetTestDir`/clients/$CLIENT_NAME/lighttpd_logging" 1

    if [ -z "$CLIENT_REMOTECLIENT" ]; then
        # Send your client files here
        # Note that a binary client only needs to be sent when it is not assumed to be available (or have been built) remotely
        # This also means that, even when building the client locally, the uploading of the resulting binary is still to be done here
        if [ -d `sourceLocalLocation`/lighttpd-*/src -a -f `sourceLocalLocation`/lighttpd-*/src/lighttpd ]; then
            # Compilation directory for lighttpd
            hostSendFile `sourceLocalLocation`/lighttpd-*/src/lighttpd `hostGetTestDir`/clients/$CLIENT_NAME/lighttpd 1
            hostSendFile `sourceLocalLocation`/lighttpd-*/src/mod_status.la `hostGetTestDir`/clients/$CLIENT_NAME/mod_status.la 1
            hostSendFile `sourceLocalLocation`/lighttpd-*/src/.libs/mod_status.so `hostGetTestDir`/clients/$CLIENT_NAME/mod_status.so 1
            hostSendFile `sourceLocalLocation`/lighttpd-*/src/mod_indexfile.la `hostGetTestDir`/clients/$CLIENT_NAME/mod_indexfile.la 1
            hostSendFile `sourceLocalLocation`/lighttpd-*/src/.libs/mod_indexfile.so `hostGetTestDir`/clients/$CLIENT_NAME/mod_indexfile.so 1
            hostSendFile `sourceLocalLocation`/lighttpd-*/src/mod_dirlisting.la `hostGetTestDir`/clients/$CLIENT_NAME/mod_dirlisting.la 1
            hostSendFile `sourceLocalLocation`/lighttpd-*/src/.libs/mod_dirlisting.so `hostGetTestDir`/clients/$CLIENT_NAME/mod_dirlisting.so 1
            hostSendFile `sourceLocalLocation`/lighttpd-*/src/mod_staticfile.la `hostGetTestDir`/clients/$CLIENT_NAME/mod_staticfile.la 1
            hostSendFile `sourceLocalLocation`/lighttpd-*/src/.libs/mod_staticfile.so `hostGetTestDir`/clients/$CLIENT_NAME/mod_staticfile.so 1
        else
            # Installation prefix for lighttpd
            hostSendFile `sourceLocalLocation`/bin/lighttpd `hostGetTestDir`/clients/$CLIENT_NAME/lighttpd 1
            hostSendFile `sourceLocalLocation`/lib/mod_status.la `hostGetTestDir`/clients/$CLIENT_NAME/mod_status.la 1
            hostSendFile `sourceLocalLocation`/lib/mod_status.so `hostGetTestDir`/clients/$CLIENT_NAME/mod_status.so 1
            hostSendFile `sourceLocalLocation`/lib/mod_indexfile.la `hostGetTestDir`/clients/$CLIENT_NAME/mod_indexfile.la 1
            hostSendFile `sourceLocalLocation`/lib/mod_indexfile.so `hostGetTestDir`/clients/$CLIENT_NAME/mod_indexfile.so 1
            hostSendFile `sourceLocalLocation`/lib/mod_dirlisting.la `hostGetTestDir`/clients/$CLIENT_NAME/mod_dirlisting.la 1
            hostSendFile `sourceLocalLocation`/lib/mod_dirlisting.so `hostGetTestDir`/clients/$CLIENT_NAME/mod_dirlisting.so 1
            hostSendFile `sourceLocalLocation`/lib/mod_staticfile.la `hostGetTestDir`/clients/$CLIENT_NAME/mod_staticfile.la 1
            hostSendFile `sourceLocalLocation`/lib/mod_staticfile.so `hostGetTestDir`/clients/$CLIENT_NAME/mod_staticfile.so 1
        fi

        if [ -d `sourceLocalLocation`/aria2-*/src -a -f `sourceLocalLocation`/aria2-*/src/aria2c ]; then
            # Compilation directory for aria2
            hostSendFile `sourceLocalLocation`/aria2-*/src/aria2c `hostGetTestDir`/clients/$CLIENT_NAME/aria2c 1
        else
            # Installation prefix for aria2
            hostSendFile `sourceLocalLocation`/bin/aria2c `hostGetTestDir`/clients/$CLIENT_NAME/aria2c 1
        fi
    else
        local ans=""
        local remoteDir="`sourceRemoteLocation`"
        ans=`hostSendCommand "[ -d $remoteDir/lighttpd-*/src ] && echo -n \"OK\""`
        if [ "$ans" = "OK" ]; then
            # Remote compilation directory for lighttpd
            hostSendCommand "cp $remoteDir/lighttpd-*/src/lighttpd $remoteDir/lighttpd-*/src/mod_status.la $remoteDir/lighttpd-*/src/.libs/mod_status.so $remoteDir/lighttpd-*/src/mod_indexfile.la $remoteDir/lighttpd-*/src/.libs/mod_indexfile.so $remoteDir/lighttpd-*/src/mod_dirlisting.la $remoteDir/lighttpd-*/src/.libs/mod_dirlisting.so $remoteDir/lighttpd-*/src/mod_staticfile.la $remoteDir/lighttpd-*/src/.libs/mod_staticfile.so $remoteDir/"
        fi
        ans=`hostSendCommand "[ -d $remoteDir/aria2-*/src ] && echo -n \"OK\""`
        if [ "$ans" = "OK" ]; then
            # Remote compilation directory for aria2
            hostSendCommand "cp $remoteDir/aria2-*/src/aria2c \"$remoteDir/\""
        fi
    fi
}

##
# Does client/execution specific preparation on the host as well as copying execution specific files of the client to the host.
# Can also build and send scripts for running the client on the host. Be sure to take CLIENT_PARAMS into account, in that case.
# Use the host API for sending files and executing commands. Use the file API for getting the right file.
# Use the execution API to find information about the specific run, such as an execution specific number.
##
function clientPrepareExecution() {
    # The default implementation wants one argument: the command line to run your client.
    # This should either be semicolon separated only have the last command really run the (blocking) client, or be enclosed in parentheses.
    # The runner script will first cd to the build dir if a remote build is done, the remote directory if a binary client is not build and assumed to be available remotely, and the client's temporary directory on the host otherwise.
    #
    # Examples of using clientPrepare__default:
    # - clientPrepare__default  "./runMyClient"
    # - clientPrepare__default  "( ./clientPart1; ./clientPart2; ./clientCleanup )"
    #
    # Please make sure to take $CLIENT_REMOTECLIENT into account in your command line.
    #
    # When redirecting logs, please make sure you place them in hostGetPersistentTestDir, or you might not be able to download them after the client has finished executing.
    #
    # Apart from creating the runner script, the default implementation creates a number of remote directories:
    # `hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber` and `hostGetTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`
    # `hostGetPersistentTestDir`/clients/$CLIENT_NAME/exec_`executionNumber` and `hostGetPersistentTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`
    if [ -z "$EXECUTION_SEEDER" ]; then
        local myExecNum=`executionNumber`
        local execNum=""
        local seeders=""
        local seederhost=""
        local nseeders=0
        local filename="`fileGetName`"
        filename="`basename $filename`"
        if [ -z "$filename" ]; then
            logError "client:http :: HTTP leeching client $CLIENT_NAME can't find the file name to leech from file $FILE_NAME: fileGetName returns \"`fileGetName`\""
            fail
        fi
        for execNum in `seq 0 $((${EXECUTION_COUNT} - 1))`; do
            executionLoadSettings $execNum
            if [ -z "$EXECUTION_SEEDER" ]; then
                continue
            fi
            executionLoadHost
            seederhost=`hostGetAddress`
            if [ -z "$seederhost" ]; then
                logError "client:http :: HTTP leeching client $CLIENT_NAME requires all seeders to give their address, but hostGetAddress for host $HOST_NAME returns \"\""
                fail
            fi

            seeders="$seeders \"http://$seederhost:3000/$filename\""
            nseeders=$(($nseeders + 1))
        done
        executionLoadSettings $myExecNum
        executionLoadHost
        if [ $nseeders = 0 ]; then
            logError "client:http :: HTTP leeching client $CLIENT_NAME does not support leeching 0 seeders"
            fail
        fi
        # Leecher client: run aria2
        # -j #seeders                           # maximum concurrent downloads
        # -s #seeders                           # split file in n parts
        # --human-readable=false                # full output
        # --summary-interval=1                  # give output every 1 sec
        # --no-conf=true                        # don't read global conf
        # --truncate-console-readout=false      # don't truncate output
        # -n                                    # don't read global .netrc conf
        # --max-tries=0                         # don't give up
        # --retry-wait=1                        # wait 1 sec between retries
        # --dir=`hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber`/   # save here
        clientPrepareExecution__default "./aria2c -j $nseeders -s $nseeders --human-readable=false --summary-interval=1 --no-conf=true --truncate-console-readout=false -n --max-tries=0 --retry-wait=1 --dir=`hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber`/ $seeders > `hostGetPersistentTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`/log.log"
    else
        # Seeder client: run lighttpd
        clientPrepareExecution__default "`hostGetTestDir`/clients/$CLIENT_NAME/lighttpd_logging `hostGetTestDir`/clients/$CLIENT_NAME `hostGetTestDir`/clients/$CLIENT_NAME/exec_`executionNumber` `fileGetName` > `hostGetPersistentTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`/log.log"
    fi

    # The default implementation can be used to build the runner script. Do any extra execution specific preparation for your client here.
    # As long as you place thing in the directories mentioned above, everything will be cleaned up.
}

##
# Does client/execution specific cleanup.
# Use the host API for issuing commands.
##
function clientCleanupExecution() {
    # The default implementation should be called for forwards compatibility (it is currently empty)
    clientCleanupExecution__default
}

##
# Does client/host specific cleanup and removes the client from the host.
# Use the host API for issuing commands.
##
function clientCleanupHost() {
    # The default implementation removes the remotely created directories
    # As long as all your things are in the directories created by the default implementation of clientPrepareHost, the default is good for you.
    clientCleanupHost__default
}

##
# Does the final client cleanup.
# This function is called once after all execution and host specific cleanup is done.
##
function clientCleanupFinal() {
    # The default implementation removes the cleanup files
    # This is probably just fine for you
    clientCleanupFinal__default

    # Note that, because of the symmetry of this function with clientReadSettings, this functions is also called when just testing the settings for correctness.
}

##
# Retrieves the client specific logs from the host.
# The logs are to be stored in the local directory pointed to by $1
# Use the host API for retrieving the logs.
# Use the execution API to find information about the specific run, such as an execution specific number.
#
# @param    The local directory in which the logs are to be saved.
##
function clientRetrieveLogs() {
    hostGetFile "`hostGetPersistentTestDir`/logs/$CLIENT_NAME/exec_`executionNumber`/log.log" "$1/log.log"
}

##
# Loads the default parser object for this client.
# This will load either the parser as defined by CLIENT_PARSER or parser:$CLIENT_SUBTYPE if the former is not defined.
##
function clientLoadDefaultParser() {
    if [ ! -z ${CLIENT_PARSER} ]; then
        parserLoadSettings "${CLIENT_PARSER}"
    else
        if [ -z "$EXECUTION_SEEDER" ]; then
            loadModule "parser/aria2"
        else
            loadModule "parser/lighttpd"
        fi
        parserLoadDefaultSettings
    fi
}

##
# Outputs the protocol used for actual traffic.
# This value is used for setting up traffic control, if desired.
# Typical values are "UDP", "TCP", etc.
#
# When a TC module finds a protocol it can't handle explicitly, or "", it will fallback to full traffic control, i.e. controlling all traffic between involved hosts.
#
# @output   The protocol used for traffic.
##
function clientTrafficProtocol() {
    echo "TCP"
}

##
# Outputs a list of inbound ports on which all incoming traffic can be controlled.
# This list is used for setting up traffic control, if desired.
#
# This list should only be given if it is definite: the idea is that when all involved clients give such a list, the testing environment will try to set up traffic control by controlling all inbound traffic on all clients.
#
# Specify "" if no such list can be given (i.e. the program does not listen on specific ports or uses dynamic allocation of ports).
#
# The specific notation of ports depends on the protocol specified in clientTrafficProtocol.
#
# @output   The list of inbound ports that would capture all incoming traffic.
##
function clientTrafficInboundPorts() {
    echo ""
}

##
# Outputs a list of outbound ports on which all outgoing traffic can be controlled.
# This list is used for setting up traffic control, if desired.
#
# This list should only be given if it is definite: the idea is that when all involved clients give such a list, the testing environment will try to set up traffic control by controlling all outbound traffic on all clients.
#
# Specify "" if no such list can be given (i.e. the program does not send from specific ports or uses dynamic allocation of ports).
#
# The specific notation of ports depends on the protocol specified in clientTrafficProtocol.
#
# @output   The list of outbound ports that would capture all outgoing traffic.
##
function clientTrafficOutboundPorts() {
    echo "3000"
}

##
# This function returns the API version implemented in this object.
# You should always leave this number in tact, unless you have upgraded the module to another version.
# This version number is used to check compatibilities with the core.
#
# @output   The API version number.
##
function clientAPIVersion() {
    echo "1.0.3"
}
