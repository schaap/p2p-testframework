#!/bin/bash

#
# The default implementations for the processor API.
# Module implementors can copy these functions if they really wish to change them, or just call them if needed.
# Whenever copying, please do NOT overwrite the default implementations, but just the actual API function.
#

##
# Returns the API version of this defaults file.
# This function should not be used by implementations!
#
# @output   The API version
##
function processorAPIVersion__default() {
    echo "1.0.1"
}

##
# Read settings from the provided settings file and save them to ${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBER .
# This default implementation just writes all the default parameters to "${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBER/conf"
##
function processorReadSettings__default() {
    mkdir -p "${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBER/"
    echo -n "$PROCESSOR_SUBTYPE" > "${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBER/modulename"

    # Save all settings, including the generic ones, to a file
    # Easiest is just a bash script that sets all variables, but anything is allowed as long as ${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBEr/ is created and ${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBER/modulename contains the module subtype.
    echo "#!/bin/bash" > "${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBER/conf"
    echo "PROCESSOR_NUMBER=\"$PROCESSOR_NUMBER\"" >> "${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBER/conf"
    echo "PROCESSOR_SUBTYPE=\"$PROCESSOR_SUBTYPE\"" >> "${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBER/conf"
}

##
# Loads previously saved settings into memory by loading "${LOCAL_TEST_DIR}/processors/proc_$1/conf"
# Checks "${LOCAL_TEST_DIR}/processors/proc_$1/modulename" against "$2" to be sure the correct module type will be loaded and offloads to the correct module is needed
#
# This default implementation complements the default implementation for processorReadSettings
#
# @param    The number of the processor object to be loaded.
# @param    The name of this module subtype
##
function processorLoadSettings__default() {
    if [ ! -d "${LOCAL_TEST_DIR}/processors/proc_$1" ]; then
        logError "processor:_defaults_ :: Can't load settings for processor $1"
        fail
    fi
    if [ `cat "${LOCAL_TEST_DIR}/processors/proc_$1/modulename"` != "$2" ]; then
        function processorAPIVersion() {
            echo "wrong"
        }
        loadModule processor/`cat "${LOCAL_TEST_DIR}/processors/proc_$1/modulename"`
        if [ "`processorAPIVersion`" != `processorAPIVersion__default` ]; then
            logError "processor:_defaults_ :: API version mismatch: the core expects API version `processorAPIVersion__default` but module processor:`cat "${LOCAL_TEST_DIR}/processors/$1/modulename"` seems to have API version `processorAPIVersion`."
            fail
        fi
        processorLoadSettings $1
        return
    fi
    . "${LOCAL_TEST_DIR}/processors/proc_$1/conf"
}

##
# Processes the raw and parsed logs found in the base directory.
# The raw logs are found in exec_${execNum}/logs/.
# The parsed logs are found in exec_${execNum}/parsedLogs/.
# Here, ${execNum} ranges from 0 to $((${EXECUTION_COUNT} - 1)), inclusive.
#
# It migt happen that more information about the executions or their parts is required.
# In such cases, use the Execution API to load the execution and continue from there on.
# For example, to figure out the client module subtype of execution $execNum:
#   executionLoadSettings $execNum
#   executionLoadClient
#   currentExecutionClientType=$CLIENT_SUBTYPE
#
# No default implementation
#
# @param    The base directory for the logs.
# @param    The directory in which to place processed results.
##
#function processorProcessLogs() {
#    for execNum in `seq 0 $((${EXECUTION_COUNT} - 1))`; do
#        local rawLogDir="$1/exec_${execNum}/logs"
#        local parsedLogDir="$1/exec_${execNum}/parsedLogs"
#        echo "TO BE IMPLEMENTED"
#    done
#}
