#!/bin/bash

#
# A gnuplot processor. This processor just loads a defined script that will run on the (parsed) logs.
# Scripts to be run using this processor will be prepended with four string variables:
# - indir       The path to the directory on the local machine containing the parsed logs
# - rawdir      The path to the directory on the local machine containing the raw logs
# - outdir      The path to the directory on the local machine where the output files should be stored
# - execnum     The number of the execution being processed
#
# This module has the following parameters:
# - script      Path to the gnuplot script to be run
#
# This module expects the following raw logs to be present:
# - gnuplot script dependent
#
# This module expects the following parsed logs to be present:
# - gnuplot script dependent
#
# This module outputs the following generated files:
# - gnuplot script dependent
#

##
# Read settings from the provided settings file and save them to ${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBER .
# Please return false (non-0) when an error occurs, instead of calling fail.
# The way the settings are saved into ${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBER/ does not matter, but make sure it exists and that ${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBER/modulename contains the module subtype and nothing else.
#
# @param    The settings file to read from.
# @param    The line number at which this processor object was defined. The first line in the settings file is at line $(($2 + 1))
#
# @return   True (0) iff the settings were parsed and saves succesfully.
##
function processorReadSettings() {
    local parameterName=""
    local parameterValue=""
    LINE_NUMBER=$(($2 + 1))
    # Parse all parameters
    PROCESSOR_GNUPLOT_SCRIPT=""
    while IFS="" read LINE; do
        if [ "" = "$LINE" ]; then
            LINE_NUMBER=$(($LINE_NUMBER + 1))
            continue
        fi

        parameterName=`getParameterName "$LINE"`
        checkFailScenarioFile "$6"
        parameterValue=`getParameterValue "$LINE"`
        # Handle this parameter appropiately
        case $parameterName in
            script)
                if [ ! -z "$PROCESSOR_GNUPLOT_SCRIPT" ]; then
                    logError "processor:gnuplot :: a gunplot processor can only have one script parameter, first one is \"$PROCESSOR_GNUPLOT_SCRIPT\", the second one is \"$parameterValue\" and was found on line $LINE_NUMBER."
                    return 1
                fi
                if [ ! -f "$parameterValue" ]; then
                    logError "processor:gnuplot :: script points to \"$parameterValue\", but that seems not to exist (line $LINE_NUMBER)."
                    return 1
                fi
                PROCESSOR_GNUPLOT_SCRIPT="$parameterValue"
                ;;
            *)
                logError "processor:gnuplot :: Unknown parameter name \"$parameterName\" in processor $PROCESSOR_NUMBER. Ignoring."
                ;;
        esac
        LINE_NUMBER=$(($LINE_NUMBER + 1))
    done < "$1";

    if [ -z "$PROCESSOR_GNUPLOT_SCRIPT" ]; then
        logError "processor:gnuplot :: a gnuplot processor must have a script specified."
        return 1
    fi

    # Delegate the rest to the default implementation
    processorReadSettings__default
    # Any variables set up above should be saved like this:
    # echo "YOUR_SETTING=\"$YOUR_SETTING\"" >> "${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBER/conf"
    echo "PROCESSOR_GNUPLOT_SCRIPT=\"$PROCESSOR_GNUPLOT_SCRIPT\"" >> "${LOCAL_TEST_DIR}/processors/proc_$PROCESSOR_NUMBER/conf"

    return 0
}

##
# Loads previously saved settings into memory.
# Be sure to override all relevant variables, whether they're saved or not.
#
# @param    The name of the file object to be loaded.
##
function processorLoadSettings() {
    # By default delegated to the default implementation, which works fine if the default implementation for processorReadSettings is used
    processorLoadSettings__default "$1" "gnuplot"
}

##
# Processes the raw and parsed logs found in the base directory.
# The raw logs are found in exec_${execNum}/logs/.
# The parsed logs are found in exec_${execNum}/parsedLogs/.
# Here, ${execNum} ranges from 0 to $((${EXECUTION_COUNT} - 1)), inclusive.
#
# It migt happen that more information about the executions or their parts is required.
# In such cases, use the Execution API to load the execution and continue from there on.
# For example, to figure out the client module subtype of execution $execNum:
#   executionLoadSettings $execNum
#   executionLoadClient
#   currentExecutionClientType=$CLIENT_SUBTYPE
#
# @param    The base directory for the logs.
# @param    The directory in which to place processed results.
##
function processorProcessLogs() {
    local scriptFile=`createTempFile`
    for execNum in `seq 0 $((${EXECUTION_COUNT} - 1))`; do
        local rawLogDir="$1/exec_${execNum}/logs"
        local parsedLogDir="$1/exec_${execNum}/parsedLogs"
        echo "indir='$parsedLogDir'" > "$scriptFile"
        echo "rawdir='$rawLogDir'" >> "$scriptFile"
        echo "outdir='$2'" >> "$scriptFile"
        echo "execnum='$execNum'" >> "$scriptFile"
        cat "$PROCESSOR_GNUPLOT_SCRIPT" >> "$scriptFile"
        A=`gnuplot < "$scriptFile"`
        if [ ! -z "$A" ]; then  
            logError "processor:gnuplot :: execution $execNum :: $A"
        fi
    done
    rm $scriptFile
}

##
# This function returns the API version implemented in this object.
# You should always leave this number in tact, unless you have upgraded the module to another version.
# This version number is used to check compatibilities with the core.
#
# @output   The API version number.
##
function processorAPIVersion() {
    echo "1.0.4"
}
