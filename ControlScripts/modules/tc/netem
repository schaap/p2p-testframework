#!/bin/bash

#
# A netem implementation of the TC API.
#
# This module uses the linux netem module to emulate network conditions. Capping on upload and
# download speed are also supported using the htb and tbf modules, respectively. As such it is
# quite possible to actually use this netem tc module without actually having any netem module
# active on the remote hosts.
#
# REQUIREMENTS
#
# This module requires that the host on which it is to be installed supports netem
# (http://www.linuxfoundation.org/collaborate/workgroups/networking/netem)
# and allows the user logging in to use sudo to use the tc utility (from the iproute2 package).
# For inbound traffic control the module requires the presence (and availability to the user)
# of IFB (http://www.linuxfoundation.org/collaborate/workgroups/networking/ifb). These
# requirements are checked automatically, but see below.
#
# Running tc under wudo without a password requires that an administrator of the remote host
# adds permissions for that in the sudoers file. A permission line for running tc without a
# password looks like this:
#   thomas  ALL = NOPASSWD: /sbin/tc
# This allows user thomas to run /sbin/tc on ALL hosts without supplying extra authentication.
# Administrators of remote hosts will most likely want to limit the hosts on which you're allowed
# to do this; 'man sudoers' will be their friend then, if needed.
#
# CHECKING AND TESTING
#
# WARNING!
# This module can easily be abused to block out all traffic from or to a host! This can
# also mean you can block out this very host from commanding the remote host. be sure to always
# verify that traffic from the commanding host CAN'T be blocked out by ensuring it is not in any
# of the ranges of hosts provided in your scenario. If you *do* block yourself you'll probably
# need physical access to the remote machine, so be sure to double check and test your settings
# before running them on some remote machine set in a bunker at the other side of the world.
# WARNING!
#
# It is advisable to always test a configuration that includes traffic control with netem in a dummy
# scenario using a fallback option. This can be done by writing a simple scenario that does include
# all traffic control that will be found in your final scenarios. For each host on which netem
# will be used, one then opens a connection to that host and run the following simple bash script:
#   ( sleep 600; sudo tc qdisc del dev eth0 root; sudo tc qdisc del dev eth0 ingress ) &
# This script will wait for 10 minutes (600 seconds, adjust to wait longer than your dummy scenario)
# and then remove all traffic control introduced by this module on interface eth0 (adjust to
# correspond to the interface that should have traffic control on that host, according to your
# scenario). The ( ... ) & construction groups the commands into a separate process and runs them
# in the background. This ensures they will be run, even if the connection is destroyed.
#
# Once you have this simple script in place on all the hosts that need it, you can run your dummy
# scenario (presumably using a dummy campaign). If everything looks fine it is expected that all
# connections to your hosts are still there. If not, you should investigate why. If all connections
# are still present you can stop the small scripts you started above by issuing the command
#   %1
# to call it back to the foreground, at which point you can just press Ctrl+C to kill it. You can
# also look up the process using a utility like ps and kill it by sending a signal.
#
# If things inadvertently went wrong (e.g. you accidently made the connection between your
# command host and the remote host very lossy) the little script will remove all problems after the
# timeout you set on it (10 minutes in the example).
#
# The safest is to also check whether any form of traffic control was used on the remote hosts before
# you started the scenario, and to check whether some is still present after the scenario has been
# run. Use the command
#   tc qdisc ls dev eth0
# to list any existing traffic controllers on the device eth0 (again, adjust as needed). This should
# yield just one line, similar to:
#   qdisc pfifo_fast 0: root refcnt 2 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1
# Most important is the second word, which tells you what type of traffic control is present. Some
# form is always present, in the form of pfifo_fast or pfifo. These mean effectively no control and
# are the situation you want. If any other qdisc shows up, consult with the administrator of the
# machine about this.
#
# HACKING THE AUTOMATED CHECKS
#
# For checking purposes modprobe is also used: it checks whether netem is available. To skip this
# check when no modprobe is available on the target system: check whether netem is indeed available
# (same goes for IFB if inbound traffic control is needed) and then create a dummy program named
# modprobe that always succeeds. Make sure it is then found via `which modprobe`.
#
# Also for checking purposes ifconfig is used: it checks whether the interface on which traffic
# control is requested actually exists. To skip this check when no ifconfig is available on the
# target system: check whether the requested interface is indeed available and then create a dummy
# program named ifconfig that outputs the name of that interface at the beginning of a line,
# followed by a space. Make sure it is then found via `which ifconfig`.
#
# LIMITATIONS
#
# The speed constraints are not entirely reliable: for larger files they're correct, but due to the
# way traffic is shaped, small amounts of traffic can't be shaped correctly. It's a process that
# averages out the speed over time, which means that at the beginning of a transfer a small jump in
# speed can be observed, possibly larger than the limit. This effect, however, should be very short.
#
# The way outbound traffic is controlled, requires that the maximum speed of the NIC is known. It is
# not a disaster if a larger speed is given (i.e. 100 mbit for a 10 mbit NIC) but a lower speed
# will result in decreased speeds. Currently the maximum is set for 1024mbit (i.e. gbit uplink), if
# your NIC is faster you want to adjust the value of the variable MAX at the beginning of tcInstall.
# Please also report this situation: if it happens too often, or needs to become portable, the module
# might be changed in its entirety.
#
# SETTINGS
#
# TC modules use the settings of their parent host object. All methods can use the Hosts API
# and should especially look at HOST_TC_PROTOCOL, HOST_TC_INBOUNDPORTS and HOST_TC_OUTBOUNDPORTS.
#

##
# Checks whether traffic control can be set up on the host using the current settings.
#
# @return   True (0) iff traffic control can be set up.
##
function tcCheck() {
    # Check for all necessary parts on the host

    # Check for tc availability, using sudo
    ans=`hostSendCommand "which tc > /dev/null && echo -n \"OK\""`
    if [ "$ans" != "OK" ]; then 
        logError "tc:netem :: Host $HOST_NAME does not have tc installed."
        return 1
    fi
    ans=`hostSendCommand "which sudo > /dev/null && echo -n \"OK\""`
    if [ "$ans" != "OK" ]; then
        logError "tc:netem :: Host $HOST_NAME does not have sudo installed."
        return 1
    fi
    ans=`hostSendCommand "\`which sudo\` -n -l \`which tc\` > /dev/null 2>/dev/null && echo -n \"OK\""`
    if [ "$ans" != "OK" ]; then
        logError "tc:netem :: Host $HOST_NAME does not allow using sudo without a password for running tc."
        return 1
    fi
    # Check for modprobe in order to check for modules
    ans=`hostSendCommand "which modprobe > /dev/null && echo -n \"OK\""`
    if [ "$ans" != "OK" ]; then
        logError "tc:netem :: Host $HOST_NAME does not have modprobe installed, which is used for checking netem availability. To bypass this check, please see the documentation in the module."
        return 1
    fi
    # Check for netem module
    ans=`hostSendCommand "\`which modprobe\` -n sch_netem 2>/dev/null && echo -n \"OK\""`
    if [ "$ans" != "OK" ]; then
        logError "tc:netem :: Host $HOST_NAME does not seem to have the netem module available or builtin."
        return 1
    fi
    ans=`hostSendCommand "\`which modprobe\` sch_netem 2>/dev/null && echo -n \"OK\""`
    if [ "$ans" != "OK" ]; then
        # netem is not loaded yet, try and load it
        ans=`hostSendCommand "\`which sudo\` -n \`which modprobe\` sch_netem > /dev/null 2>/dev/null && echo -n \"OK\""`
        if [ "$ans" != "OK" ]; then
            logError "tc:netem :: Host $HOST_NAME has netem support, but the module could not be loaded. Do you have the right to use sudo on modprobe without a password? Please load the module manually and try again."
            return 1
        fi
    fi
    # If we need to do some inbound traffic control, we also need IFB
    if [ "$HOST_TC_INBOUNDPORTS" != "" ]; then
        # Check for the IFB module
        ans=`hostSendCommand "\`which modprobe\` -n ifb 2>/dev/null && echo -n \"OK\""`
        if [ "$ans" != "OK" ]; then
            logError "tc:netem :: Host $HOST_NAME does not seem to have the ifb module available or builtin, this is required for inbound traffic control."
            return 1
        fi
        ans=`hostSendCommand "\`which modprobe\` ifb 2>/dev/null && echo -n \"OK\""`
        if [ "$ans" != "OK" ]; then
            # IFB is not loaded yet, try and load it
            ans=`hostSendCommand "\`which sudo\` -n \`which modprobe\` ifb > /dev/null 2>/dev/null && echo -n \"OK\""`
            if [ "$ans" != "OK" ]; then
                logError "tc:netem :: Host $HOST_NAME has IFB support, but the module could not be loaded. Do you have the right to use sudo on modprobe without a password? Please load the module manually and try again."
                return 1
            fi
        fi
    fi
    # Check whether the requested interface is available
    ans=`hostSendCommand "which ifconfig >/dev/null && echo -n \"OK\""`
    if [ "$ans" != "OK" ]; then
        logError "tc:netem :: Host $HOST_NAME does not have ifconfig installed, which is used for checking the availability of interface $HOST_TC_IFACE, on which to do traffic control. To bypass this check, please see the documentation in the module."
        return 1
    fi
    ans=`hostSendCommand "\`which ifconfig\` | grep -E \"^$HOST_TC_IFACE[[:space:]]\" > /dev/null && echo -n \"OK\""`
    if [ "$ans" != "OK" ]; then
        logError "tc:netem :: Host $HOST_NAME does not seem to have an interface called \"$HOST_TC_IFACE\", on which traffic control was requested."
        return 1
    fi
    # If we need to do some inbound traffic, interface ifb0 should be up as well
    if [ "$HOST_TC_INBOUNDPORTS" != "" ]; then
        ans=`hostSendCommand "\`which ifconfig\` | grep -E \"^ifb0[[:space:]]\" > /dev/null && echo -n \"OK\""`
        if [ "$ans" != "OK" ]; then 
            # Try and get the link up
            (hostSendCommand "\`which sudo\` \`which ip\` link set dev ifb0 up")
            ans=`hostSendCommand "\`which ifconfig\` | grep -E \"^ifb0[[:space:]]\" > /dev/null && echo -n \"OK\""`
            if [ "$ans" != "OK" ]; then
                logError "tc:netem :: Host $HOST_NAME has IFB support and the module is loaded, but it was not possible to get the link up. Please manually enable it, e.g. using \"sudo ip link set dev ifb0 up\"."
                return 1
            fi
        fi
    fi
    return 0
}

##
# Installs traffic control on the currently loaded host with the currently loaded settings.
# Note that this function can't influence the surrounding environment due to the way it is called.
#
# @param    A space separated list of subnets of the other hosts.
##
function tcInstall() {
    # rate is required for all classes, if you have a NIC with mult-gbit uplink, please adjust this
    local MAX=1024mbit

    local TC="\`which sudo\` -n \`which tc\`"
    local tccommands="dbgfile=`mktemp`; if [ ! -f \"\$dbgfile\" ]; then echo \"Could not create temporary file for debug.\"; exit; fi"
    tccommands="$tccommands; echo \"Cleaning before starting\" >> \"\$dbgfile\""
    # Inbound traffic control, if needed (cleanup)
    if [ "$HOST_TC_INBOUNDPORTS" != "" ]; then
        # cleanup
        tccommands="$tccommands; echo \"Cleaning before starting\" >> \"\$dbgfile\""
        tccommands="$tccommands; $TC qdisc del dev $HOST_TC_IFACE ingress 2>/dev/null"
        tccommands="$tccommands; $TC qdisc del dev ifb0 root 2>/dev/null"
    fi
    # Outbound traffic control, if needed (cleanup)
    if [ "$HOST_TC_OUTBOUNDPORTS" != "" ]; then
        # cleanup
        tccommands="$tccommands; $TC qdisc del dev $HOST_TC_IFACE root 2>/dev/null"
    fi
    tccommands="$tccommands; echo \"Cleanup done, setting up tc\" >> \"\$dbgfile\""
    # Inbound traffic control, if needed
    if [ "$HOST_TC_INBOUNDPORTS" != "" ]; then
        tccommands="$tccommands && echo \"INBOUND TRAFFIC\" >> \"\$dbgfile\""
        # add ingress
        tccommands="$tccommands && echo \"Adding ingress\" >> \"\$dbgfile\""
        tccommands="$tccommands && $TC qdisc add dev $HOST_TC_IFACE ingress 2>> \"\$dbgfile\""
        # redirect to ifb0
        if [ "$HOST_TC_INBOUNDPORTS" = "-1" ]; then
            for hostname in $1; do
                tccommands="$tccommands && echo \"Redirecting source host $hostname to ifb\" >> \"\$dbgfile\""
                tccommands="$tccommands && $TC filter add dev $HOST_TC_IFACE parent ffff: protocol ip prio 1 u32 match ip src $hostname flowid 1:1 action mirred egress redirect dev ifb0 2>> \"\$dbgfile\""
            done
        else
            for port in $HOST_TC_INBOUNDPORTS; do
                tccommands="$tccommands && echo \"Redirecting destination port $port to ifb\" >> \"\$dbgfile\""
                tccommands="$tccommands && $TC filter add dev $HOST_TC_IFACE parent ffff: protocol ip prio 1 u32 match ip dport $port 0xffff flowid 1:1 action mirred egress redirect dev ifb0 2>> \"\$dbgfile\""
            done
        fi
        # Set the parameters for the inbound traffic control
        local tccmd=""
        if [ "$HOST_TC_LOSS" != "0.0" ]; then
            tccmd="$tccmd loss $HOST_TC_LOSS%"
        fi
        if [ "$HOST_TC_CORRUPTION" != "0.0" ]; then
            tccmd="$tccmd corrupt $HOST_TC_CORRUPTION%"
        fi
        if [ "$HOST_TC_DUPLICATION" != "0.0" ]; then
            tccmd="$tccmd duplicate $HOST_TC_DUPLICATION%"
        fi
        local hasnetem=0
        if [ ! -z "$tccmd" ]; then
            tccommands="$tccommands && echo \"Setting up netem using options $tccmd\" >> \"\$dbgfile\""
            tccommands="$tccommands && $TC qdisc add dev ifb0 root handle 1: netem $tccmd 2>> \"\$dbgfile\""
            hasnetem=1
        else
            tccommands="$tccommands && echo \"Not using netem module\" >> \"\$dbgfile\""
        fi
        tccmd=""
        if [ "$HOST_TC_DOWN" != "" ]; then
            tccmd="$tccmd rate $HOST_TC_DOWN"
            if [ "$HOST_TC_DOWN_BURST" != "" ]; then
                tccmd="$tccmd burst $HOST_TC_DOWN_BURST"
            else
                tccmd="$tccmd burst $HOST_TC_DOWN"
            fi
        fi

        if [ ! -z "$tccmd" ]; then
            if [ $hasnetem -eq 0 ]; then
                tccommands="$tccommands && echo \"Adding tbf to ifb0 using options $tccmd latency 50ms\" >> \"\$dbgfile\""
                tccommands="$tccommands && $TC qdisc add dev ifb0 root handle 10: tbf $tccmd latency 50ms 2>> \"\$dbgfile\""
            else
                tccommands="$tccommands && echo \"Adding tbf to ifb0 under netem using options $tccmd latency 50ms\" >> \"\$dbgfile\""
                tccommands="$tccommands && $TC qdisc add dev ifb0 parent 1:1 handle 10: tbf $tccmd latency 50ms 2>> \"\$dbgfile\""
            fi
        fi
    fi
    # Outbound traffic control, if needed
    if [ "$HOST_TC_OUTBOUNDPORTS" != "" ]; then
        tccommands="$tccommands && echo \"OUTBOUND TRAFFIC\" >> \"\$dbgfile\""

        # Add netem on the throttled connection
        local hasnetem=0
        if [ "$HOST_TC_DELAY" != "0ms" ]; then
            tccommands="$tccommands && echo \"Adding netem under controlled class with delay $HOST_TC_DELAY\" >> \"\$dbgfile\""
            tccommands="$tccommands && $TC qdisc add dev $HOST_TC_IFACE root handle 51: netem delay $HOST_TC_DELAY 2>> \"\$dbgfile\""
            hasnetem=1
        else
            tccommands="$tccommands && echo \"No netem needed: no delay to be introduced\" >> \"\$dbgfile\""
        fi

        # For outbound traffic speed control, we'll use htb, the Hierarchical Token Bucket (http://luxik.cdi.cz/~devik/qos/htb/)

        if [ $hasnetem -eq 0 ]; then
            tccommands="$tccommands && echo \"Setting up htb\" >> \"\$dbgfile\""
            tccommands="$tccommands && $TC qdisc add dev $HOST_TC_IFACE root handle 50: htb default 11 2>> \"\$dbgfile\""
        else
            tccommands="$tccommands && echo \"Setting up htb under netem\" >> \"\$dbgfile\""
            tccommands="$tccommands && $TC qdisc add dev $HOST_TC_IFACE parent 51: handle 50: htb default 11 2>> \"\$dbgfile\""
        fi
        tccommands="$tccommands && echo \"Adding base class to htb (rate $MAX)\" >> \"\$dbgfile\""
        tccommands="$tccommands && $TC class add dev $HOST_TC_IFACE parent 50: classid 50:1 htb rate $MAX burst $MAX 2>> \"\$dbgfile\""
        if [ ! -z "$HOST_TC_UP" ]; then
            if [ ! -z "$HOST_TC_UP_BURST" ]; then
                tccommands="$tccommands && echo \"Setting up controlled class (rate $HOST_TC_UP, burst $HOST_TC_UP_BURST)\" >> \"\$dbgfile\""
                tccommands="$tccommands && $TC class add dev $HOST_TC_IFACE parent 50: classid 50:10 htb rate $HOST_TC_UP burst $HOST_TC_UP_BURST 2>> \"\$dbgfile\""
            else
                tccommands="$tccommands && echo \"Setting up controlled class (rate $HOST_TC_UP)\" >> \"\$dbgfile\""
                tccommands="$tccommands && $TC class add dev $HOST_TC_IFACE parent 50: classid 50:10 htb rate $HOST_TC_UP burst $HOST_TC_UP 2>> \"\$dbgfile\""
            fi
        else
            tccommands="$tccommands && echo \"Setting up controlled class without control (just pass traffic on to netem)\" >> \"\$dbgfile\""
            tccommands="$tccommands && $TC class add dev $HOST_TC_IFACE parent 50: classid 50:10 htb rate $MAX burst $MAX 2>> \"\$dbgfile\""
        fi
        tccommands="$tccommands && echo \"Setting up default class (rate $MAX)\" >> \"\$dbgfile\""
        tccommands="$tccommands && $TC class add dev $HOST_TC_IFACE parent 50: classid 50:11 htb rate $MAX burst $MAX 2>> \"\$dbgfile\""
        if [ "$HOST_TC_OUTBOUNDPORTS" = "-1" ]; then
            for hostname in $1; do
                tccommands="$tccommands && echo \"Filtering destination host $hostname to controlled class\" >> \"\$dbgfile\""
                tccommands="$tccommands && $TC filter add dev $HOST_TC_IFACE parent 50: protocol ip prio 1 u32 match ip dst $hostname flowid 50:10 2>> \"\$dbgfile\""
            done
        else
            for port in $HOST_TC_OUTBOUNDPORTS; do
                tccommands="$tccommands && echo \"Filtering source port $port to controlled class\" >> \"\$dbgfile\""
                tccommands="$tccommands && $TC filter add dev $HOST_TC_IFACE parent 50: protocol ip prio 1 u32 match ip sport $port 0xffff flowid 50:10 2>> \"\$dbgfile\""
            done
        fi

    fi

    # Finish nicely
    tccommands="$tccommands && rm -f \"\$dbgfile\" && echo -n \"OK\" && exit"
    # Safety measures to check that setting up has gone right; clean up if not
    # Note that these are reached only when something in the chain of setting things up fails, since those are all connected with &&
    tccommands="$tccommands; sudo tc qdisc del dev $HOST_TC_IFACE root 2> /dev/null; sudo tc qdisc del dev $HOST_TC_IFACE ingress 2> /dev/null; cat \"\$dbgfile\"; rm -f \"\$dbgfile\""

    # Execute all the commands
    # The commands are executed in a background subprocess to guard against immediately breaking connections while setting up
    local ans=`hostSendCommand "( $tccommands ) &
wait"`
    if [ "$ans" != "OK" ]; then
        # Something went wrong along the way
        if [ "$ans" == "" ]; then
            logError "tc:netem :: Setting up traffic control on host $HOST_NAME went wrong. There is no output at all, which suggests that the connection was truncated before the traffic control was completely set up."
        else
            logError "tc:netem :: Setting up traffic control on host $HOST_NAME went wrong. Please consult the debug log below for more information on what went wrong."
            logError "$ans"
        fi
        fail
    fi
}

##
# Removes traffic control from the currently loaded host with the currently loaded settings.
# Note that this function can't influence the surrounding environment due to the way it is called.
##
function tcRemove() {
    local TC="\`which sudo\` -n \`which tc\`"
    hostSendCommand "$TC qdisc del dev $HOST_TC_IFACE root 2> /dev/null"
    hostSendCommand "$TC qdisc del dev $HOST_TC_IFACE ingress 2> /dev/null"
    hostSendCommand "$TC qdisc del dev ifb0 root 2> /dev/null"
}

##
# This function returns the API version implemented in this module.
# You should always leave this number in tact, unless you have upgraded the module to another version.
# This version number is used to check compatibilities with the core.
#
# @output   The API version number.
##
function tcAPIVersion() {
    echo "1.0.3"
}
