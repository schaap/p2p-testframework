#!/bin/bash

#
# The default implementation for the host API.
# Module implementors can copy these functions if they really wish to change them, or just call them if needed.
# Whenever copying, please do NOT overwrite the default implementations, but just the actual API function.
#

##
# Returns the API version of this defaults file.
# This function should not be used by implementations!
#
# @output   The API version
##
function hostAPIVersion__default() {
    echo "1.0.4"
}

##
# Read settings from the provided settings file and save them to ${LOCAL_TEST_DIR}/hosts/$HOST_NAME .
# This default implementation just writes all the default parameters to "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
##
function hostReadSettings__default() {
    # Setup a cleanup file for this host
    addCleanupScript
    HOST_CLEANUPIDX=`newCleanupScriptIndex`
    addCleanupCommand ". \"${TEST_ENV_DIR}/modules/host/$HOST_SUBTYPE\"" $HOST_CLEANUPIDX
    HOST_TEMPFOLDER=""

    mkdir -p "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/"
    echo -n "$HOST_SUBTYPE" > "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/modulename"

    # Save all the settings, including the generic ones, to a file.
    # Easiest is just a bash script that sets all variables, but anything is allowed as long as ${LOCAL_TEST_DIR}/hosts/$HOST_NAME/ is created and ${LOCAL_TEST_DIR}/hosts/$HOST_NAME/modulename contains the module subtype.
    echo "#!/bin/bash" > "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_NAME=\"$HOST_NAME\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_PREPARATION=\"$HOST_PREPARATION\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_CLEANUP=\"$HOST_CLEANUP\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_REMOTEFOLDER=\"$HOST_REMOTEFOLDER\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_SUBTYPE=\"$HOST_SUBTYPE\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_CLEANUPIDX=\"$HOST_CLEANUPIDX\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TEMPFOLDER=\"\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC=\"$HOST_TC\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC_UP=\"$HOST_TC_UP\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC_UP_BURST=\"$HOST_TC_UP_BURST\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC_DOWN=\"$HOST_TC_DOWN\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC_DOWN_BURST=\"$HOST_TC_DOWN_BURST\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC_IFACE=\"$HOST_TC_IFACE\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC_JITTER=\"$HOST_TC_JITTER\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC_DELAY=\"$HOST_TC_DELAY\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC_LOSS=\"$HOST_TC_LOSS\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC_CORRUPTION=\"$HOST_TC_CORRUPTION\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC_DUPLICATION=\"$HOST_TC_DUPLICATION\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC_OUTBOUNDPORTS=\"$HOST_TC_OUTBOUNDPORTS\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC_INBOUNDPORTS=\"$HOST_TC_INBOUNDPORTS\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    echo "HOST_TC_PROTOCOL=\"$HOST_TC_PROTOCOL\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"

    addCleanupCommand "hostLoadSettings $HOST_NAME" $HOST_CLEANUPIDX
}

##
# Loads previously saved settings into memory by loading "${LOCAL_TEST_DIR}/hosts/$1/conf"
# Checks "${LOCAL_TEST_DIR}/hosts/$1/modulename" against "$2" to be sure the correct module type will be loaded and offloads to the correct module is needed
#
# This default implementation complements the default implementation for hostReadSettings
#
# @param    The name of the host object to be loaded.
# @param    The name of this module subtype
##
function hostLoadSettings__default() {
    if [ -z "$1" ]; then
        logError "host:_defaults_ :: Can't load settings for host \"\""
        fail
    fi
    if [ ! -d "${LOCAL_TEST_DIR}/hosts/$1" ]; then
        logError "host:_defaults_ :: Can't load settings for host $1"
        fail
    fi
    if [ `cat "${LOCAL_TEST_DIR}/hosts/$1/modulename"` != "$2" ]; then
        function hostAPIVersion() {
            echo "wrong"
        }
        loadModule host/`cat "${LOCAL_TEST_DIR}/hosts/$1/modulename"`
        if [ "`hostAPIVersion`" != `hostAPIVersion__default` ]; then
            logError "host:_defaults_ :: API version mismatch: the core expects API version `hostAPIVersion__default` but module host:`cat "${LOCAL_TEST_DIR}/hosts/$1/modulename"` seems to have API version `hostAPIVersion`."
            fail
        fi
        hostLoadSettings $1
        return
    fi
    . "${LOCAL_TEST_DIR}/hosts/$1/conf"
}

##
# Executes the given command on the loaded host.
#
# No default implementation
#
# @param    The command to be executed as one string.
#
# @output   The output of the command on the host.
##
#function hostSendCommand() {
#}

##
# Sends the given local file to the host and stores it in the specified remote path.
#
# No default implementation
#
# @param    The path to the local file to be sent.
# @param    The path on the remote host where the file is to be stored.
##
#function hostSendFile() {
#}

##
# Sends the given local directory to the host and stores it in the specified remote path.
# This function will overwrite if needed.
# This function does *not* check its succes. It optimistically assumes every operation succeeds.
#
# This default implementation does a manual recursion, sending files using hostSendFile one by one.
#
# @param    The path to the local directory of which the contents are to be sent.
# @param    The path on the remote host to the directory where the contents are to be stored.
##
function hostSendFiles__default() {
    local curdir=`pwd`
    local copydirs=( . )    # Note that this is the only time that "." or ".." is allowed: as bootstrap of the iteration.
    # Copies files and recursively creates directories and copies the files therein
    # Note that the recursion is written as an iteration using an array
    while [ ${#copydirs[@]} -gt 0 ]; do
        local copydirmax=$((${#copydirs[@]} - 1))
        local curcopydir=${copydirs[copydirmax]}
        unset copydirs[$copydirmax]
        cd "$curdir"
        cd "$1"
        cd "$curcopydir/"
        local absdir=`pwd`
        for f in `ls -a`; do
            if [ "$f" = "." -o "$f" = ".." ]; then
                continue
            fi
            if [ -d "$f" ]; then
                hostSendCommand "mkdir -p \"$2/$curcopydir/$f\""
                copydirs[${#copydirs[@]}]="$curcopydir/$f"
            fi
            if [ -f "$f" ]; then
                hostSendFile "$absdir/$f" "$2/$curcopydir/$f" 1
            fi
            # Skip strange stuff
        done
    done
    cd "$curdir"
}

##
# Retrieves a file from the host from a specified remote path and stores it at the given local path.
# Fails if the local file already exists.
#
# No default implementation
#
# @param    The path on the remote host of the file to be retrieved.
# @param    The path on the local machine where the retrieved file is to be stored.
##
#function hostGetFile() {
#}

##
# Executes the commands to do host specific preparation.
# The default implementation creates and sets up a cleanup file (index: $HOST_CLEANUPIDX), creates a remote temporary directory if no HOST_REMOTEFOLDER is given (will be placed in HOST_TEMPFOLDER, but see hostGetTestDir).
# The default implementation does NOT run the HOST_PREPARATION script, since it is anticipated module implementors may want to place code in between these initializations and the call to that script.
##
function hostPrepare__default() {
    # Set up scenario cleanup in case of failure
    addCleanupCommand "hostCleanup" $HOST_CLEANUPIDX

    # This should make sure a testing directory is available
    if [ -z "$HOST_REMOTEFOLDER" ]; then
        HOST_TEMPFOLDER=`hostSendCommand "mktemp -d"`
        if [ -z "$HOST_TEMPFOLDER" ]; then
            logError "host:_defaults_ :: Could not create temporary directory on host $HOST_NAME"
            fail
        fi
        echo "HOST_TEMPFOLDER=\"$HOST_TEMPFOLDER\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    fi
}

##
# Executes the commands to do host specific cleanup.
# The default implementation cleans up the cleanup and removes the remote temporary directory in HOST_TEMPFOLDER.
# The default implementation does NOT run the HOST_CLEANUP script to remain symmetrical with hostPrepare__default as well as for the reasons mentioned there.
##
function hostCleanup__default() {
    # Cleaning up scenario: remove cleanup script for failure
    removeCleanupScript $HOST_CLEANUPIDX
    HOST_CLEANUPIDX=""
    echo "HOST_CLEANUPIDX=\"$HOST_CLEANUPIDX\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"

    # Remove the temporary folder on the host if it was created
    if [ ! -z "$HOST_TEMPFOLDER" ]; then
        hostSendCommand "rm -rf $HOST_TEMPFOLDER"
        HOST_TEMPFOLDER=""
        echo "HOST_REMOTE_FOLDER=\"$HOST_TEMPFOLDER\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
    fi
}

##
# Outputs the (remote) directory on the host where (temporary) files are stored for the testing environment.
# This default implementation checks HOST_REMOTEFOLDER and HOST_TEMPFOLDER in that order, outputting the first to have contents (or "" if none of them does).
##
function hostGetTestDir__default() {
    if [ ! -z "$HOST_REMOTEFOLDER" ]; then
        echo "$HOST_REMOTEFOLDER"
    else
        if [ ! -z "$HOST_TEMPFOLDER" ]; then
            echo "$HOST_TEMPFOLDER"
        else
            echo ""
        fi
    fi
}

##
# Outputs the (remote) directory on the host where (temporary) files are stored for the testing environment that will remain available until the host is actually cleaned.
# This default implementation simple call hostGetTestDir
##
function hostGetPersistentTestDir__default() {
    hostGetTestDir
}

##
# Outputs the subnet of the external addresses of the host.
#
# No default implementation.
#
# @output   The subnet of the host(s).
##
#function hostGetSubnet() {
#}

##
# Outputs the single address (IP or hostname) of the host, if any.
#
# No default implementation.
#
# @output   The address of the host, or "" if no such address can be given.
##
#function hostGetAddress() {
#}

##
# Sets the list of outbound ports to be used for restricted outbound traffic control.
# This is an internal function that should never be used by others.
#
# Special values:
# - "-1"    Unrestricted control
# - ""      No control
#
# Be sure to set the variable HOST_TC_OUTBOUNDPORTS to this list and save it.
#
# @param    The list of ports.
##
function hostTCSaveOutboundPortList__default() {
    # The default implementation is alright if you use the default way of saving your settings
    HOST_TC_OUTBOUNDPORTS="$1"
    echo "HOST_TC_OUTBOUNDPORTS=\"$HOST_TC_OUTBOUNDPORTS\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
}

##
# Sets the list of inbound ports to be used for restricted inbound traffic control.
# This is an internal function that should never be used by others.
#
# Special values:
# - "-1"    Unrestricted control
# - ""      No control
#
# Be sure to set the variable HOST_TC_INBOUNDPORTS to this list and save it.
#
# @param    The list of ports.
##
function hostTCSaveInboundPortList__default() {
    # The default implementation is alright if you use the default way of saving your settings
    HOST_TC_INBOUNDPORTS="$1"
    echo "HOST_TC_INBOUNDPORTS=\"$HOST_TC_INBOUNDPORTS\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
}

##
# Sets the protocol to be used for restricted traffic control.
# This is an internal function that should never be used by others.
#
# Be sure to set the variable HOST_TC_PROTOCOL to this value and save it.
#
# @param    The name of the protocol ("UDP", "TCP", ...)
##
function hostTCSaveProtocol__default() {
    # The default implementation is alright if you use the default way of saving your settings
    HOST_TC_PROTOCOL="$1"
    echo "HOST_TC_PROTOCOL=\"$HOST_TC_PROTOCOL\"" >> "${LOCAL_TEST_DIR}/hosts/$HOST_NAME/conf"
} 
