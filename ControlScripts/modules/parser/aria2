#!/bin/bash

#
# A parser for aria2 download logs (no upload is assumed).
#
# Raw logs expected by this module:
# - log.log
# -- contains the output of aria2 (preferably with a shorter interval than the default 60s) with --human-readable=false, --truncate-console-readout=false and only one file in the download queue (possibly multiple sources)
#
# Parsed log files created by this module:
# - log.data
# -- relative time (seconds)
# -- % done
# -- upload speed (kB/s)
# -- download speed (kB/s)
#

##
# Read settings from the provided settings file and save them to ${LOCAL_TEST_DIR}/parsers/$PARSER_NAME .
# Please return false (non-0) when an error occurs, instead of calling fail.
# The way the settings are saved into ${LOCAL_TEST_DIR}/parsers/$PARSER_NAME/ does not matter, but make sure it exists and that ${LOCAL_TEST_DIR}/parsers/$PARSER_NAME/modulename contains the module subtype and nothing else.
#
# @param    The settings file to read from.
# @param    The line number at which this parser object was defined. The first line in the settings file is at line $(($2 + 1))
#
# @return   True (0) iff the settings were parsed and saves succesfully.
##
function parserReadSettings() {
    local parameterName=""
    local parameterValue=""
    LINE_NUMBER=$(($2 + 1))
    # Parse all parameters
    while IFS="" read LINE; do
        if [ "" = "$LINE" ]; then
            LINE_NUMBER=$(($LINE_NUMBER + 1))
            continue
        fi

        parameterName=`getParameterName "$LINE"`
        checkFailScenarioFile "$6"
        parameterValue=`getParameterValue "$LINE"`
        # Handle this parameter appropiately
        case $parameterName in
            name)
                # These are the generic settings that have already been parsed. Usually one can ignore them as such.
                ;;
            *)
                logError "parser:aria2 :: Unknown parameter name \"$parameterName\" in parser $PARSER_NAME. Ignoring."
                ;;
        esac
        LINE_NUMBER=$(($LINE_NUMBER + 1))
    done < "$1";

    # Delegate the rest to the default implementation
    parserReadSettings__default
    # Any variables set up above should be saved like this:
    # echo "YOUR_SETTING=\"$YOUR_SETTING\"" >> "${LOCAL_TEST_DIR}/parsers/$PARSER_NAME/conf"

    return 0
}

##
# Loads previously saved settings into memory.
# Be sure to override all relevant variables, whether they're saved or not.
#
# @param    The name of the file object to be loaded.
##
function parserLoadSettings() {
    # By default delegated to the default implementation, which works fine if the default implementation for parserReadSettings is used
    parserLoadSettings__default "$1" "aria2"
}

##
# Loads the default settings for this parser.
# Be sure to override all relevant variables, whether they have a default or not (in which case: override them with "").
##
function parserLoadDefaultSettings() {
    PARSER_NAME=""
    PARSER_SUBTYPE="aria2"
}

##
# Parse the logs for the current execution.
# Use the execution API to find out data about this particular execution.
#
# Be sure to document in the header of your module file which logs you expect to be present and with which filename.
#
# @param    logDir      The directory on the local machine where the log files are stored.
# @param    outputDir   The directory on the local machine where parsed logs are to be stored.
##
function parserParseLogs() {
    if [ ! -f "$1/log.log" ]; then
        logError "parser:aria2 :: Parser $PARSER_NAME expected log file \"$1/log.log\", but it's not there."
        fail
    fi

    if [ -f "$2/log.data" ]; then
        logError "parser:aria2 :: Data file \"$2/log.data\" should be created by parser $PARSER_NAME, but it already exists."
        fail
    fi

    touch "$2/log.data"

    if [ ! -f "$2/log.data" ]; then
        logError "parser:aria2 :: Could not touch output file $2/log.data."
        return
    fi

    echo "time percent upspeed dlspeed" > "$2/log.data"
    echo "0 0 0 0" >> "$2/log.data"

    local firstTime=-1
    local relTime=-1
    local up_bytes=0
    local down_bytes=0
    local percentDone=""
    local firstDay=""
    local day=""
    local hour=""
    local minute=""
    local second=""
    local currSize=""
    local totalSize=""
    local lastRelTime=""
    while IFS="\n" read LINE; do
        if [ "$firstTime" = "-1" ]; then
            # This happens only the first time: The first report is used as the base report. It should be noted that that very first report is given 1 sec after start, so the first report's relative time is 1
            if ! echo "$LINE" | grep -E "^ \*\*\* Download Progress Summary as of" > /dev/null; then
                continue
            fi
            day=`echo "$LINE" | sed -e "s/^ \*\*\* Download Progress Summary as of [^ ]*  *[^ ]*  *\([0-9][0-9]*\)  *.*$/\\1/"`
            if echo "$day" | grep "^0.*[1-9]$" > /dev/null; then
                day=`echo "$day" | sed -e "s/^0*\([^0]\)/\\1/"`
            fi
            hour=`echo "$LINE" | sed -e "s/^ \*\*\* Download Progress Summary as of [^ ]*  *[^ ]*  *[0-9][0-9]*  *\([0-9][0-9]*\):.*$/\\1/"`
            if echo "$hour" | grep "^0.*[1-9]$" > /dev/null; then
                hour=`echo "$hour" | sed -e "s/^0*\([^0]\)/\\1/"`
            fi
            minute=`echo "$LINE" | sed -e "s/^ \*\*\* Download Progress Summary as of [^ ]*  *[^ ]*  *[0-9][0-9]*  *[0-9][0-9]*:\([0-9][0-9]*\):.*$/\\1/"`
            if echo "$minute" | grep "^0.*[1-9]$" > /dev/null; then
                minute=`echo "$minute" | sed -e "s/^0*\([^0]\)/\\1/"`
            fi
            second=`echo "$LINE" | sed -e "s/^ \*\*\* Download Progress Summary as of [^ ]*  *[^ ]*  *[0-9][0-9]*  *[0-9][0-9]*:[0-9][0-9]*:\([0-9][0-9]*\) .*$/\\1/"`
            if echo "$second" | grep "^0.*[1-9]$" > /dev/null; then
                second=`echo "$second" | sed -e "s/^0*\([^0]\)/\\1/"`
            fi
            relTime=$(($second + 60 * $minute + 60 * 60 * $hour))
            firstDay=$day
            firstTime=$(($relTime - 1))
        fi

        if echo "$LINE" | grep -E "^ \*\*\* Download Progress Summary as of" > /dev/null; then
            # Creates a relative timestamp
            day=`echo "$LINE" | sed -e "s/^ \*\*\* Download Progress Summary as of [^ ]*  *[^ ]*  *\([0-9][0-9]*\)  *.*$/\\1/"`
            if echo "$day" | grep "^0.*[1-9]$" > /dev/null; then
                day=`echo "$day" | sed -e "s/^0*\([^0]\)/\\1/"`
            fi
            hour=`echo "$LINE" | sed -e "s/^ \*\*\* Download Progress Summary as of [^ ]*  *[^ ]*  *[0-9][0-9]*  *\([0-9][0-9]*\):.*$/\\1/"`
            if echo "$hour" | grep "^0.*[1-9]$" > /dev/null; then
                hour=`echo "$hour" | sed -e "s/^0*\([^0]\)/\\1/"`
            fi
            minute=`echo "$LINE" | sed -e "s/^ \*\*\* Download Progress Summary as of [^ ]*  *[^ ]*  *[0-9][0-9]*  *[0-9][0-9]*:\([0-9][0-9]*\):.*$/\\1/"`
            if echo "$minute" | grep "^0.*[1-9]$" > /dev/null; then
                minute=`echo "$minute" | sed -e "s/^0*\([^0]\)/\\1/"`
            fi
            second=`echo "$LINE" | sed -e "s/^ \*\*\* Download Progress Summary as of [^ ]*  *[^ ]*  *[0-9][0-9]*  *[0-9][0-9]*:[0-9][0-9]*:\([0-9][0-9]*\) .*$/\\1/"`
            if echo "$second" | grep "^0.*[1-9]$" > /dev/null; then
                second=`echo "$second" | sed -e "s/^0*\([^0]\)/\\1/"`
            fi
            relTime=$(($second + 60 * $minute + 60 * 60 * $hour))
            if [ "$day" != "$firstDay" ]; then
                relTime=$(($relTime + 24 * 60 * 60))
            fi
            relTime=$(($relTime - $firstTime))
            continue
        fi

        if echo "$LINE" | grep "NOTICE - Download complete" > /dev/null; then
            if [ "$relTime" = "-1" ]; then
                relTime=$(($lastRelTime + 1))
            fi
            echo "$relTime 100.0 0 0" >> "$2/log.data"
            relTime=-1
        fi

        if [ "$relTime" = "-1" ]; then
            # Previous timestamp used, not using it again
            continue
        fi

        if echo "$LINE" | grep -E "^\[\#1 SIZE:0B/0B CN:[0-9]* SPD:0Bs.*" > /dev/null; then
            echo "$relTime 0 0 0" >> "$2/log.data"

            # Consume timestamp
            lastRelTime=$relTime
            relTime=-1
            continue
        fi

        if echo "$LINE" | grep -E "^\[\#1 SIZE:[0-9]*B/[0-9]*B\([0-9]*%\) CN:[0-9]* SPD:[0-9]*Bs ETA:[0-9]*s\]$" > /dev/null; then
            currSize=`echo "$LINE" | sed -e "s/^\[\#1 SIZE:\([0-9]*\)B\/[0-9]*B([0-9]*%) CN:[0-9]* SPD:[0-9]*Bs ETA:[0-9]*s\]$/\\1/"`
            totalSize=`echo "$LINE" | sed -e "s/^\[\#1 SIZE:[0-9]*B\/\([0-9]*\)B([0-9]*%) CN:[0-9]* SPD:[0-9]*Bs ETA:[0-9]*s\]$/\\1/"`
            percentDone=`echo "scale=4; 100.0*($currSize / $totalSize)" | bc`

            upspeed="0"
            downspeed=`echo "$LINE" | sed -e "s/^\[\#1 SIZE:[0-9]*B\/[0-9]*B([0-9]*%) CN:[0-9]* SPD:\([0-9]*\)Bs ETA:[0-9]*s\]$/\\1/"`
            downspeed=`echo "scale=4; ($downspeed / 1024.0)" | bc`

            echo "$relTime $percentDone $upspeed $downspeed" >> "$2/log.data"

            # Consume timestamp
            lastRelTime=$relTime
            relTime=-1
        fi
    done < "$1/log.log"
}

##
# This function returns the API version implemented in this object.
# You should always leave this number in tact, unless you have upgraded the module to another version.
# This version number is used to check compatibilities with the core.
#
# @output   The API version number.
##
function parserAPIVersion() {
    echo "1.0.3"
}
